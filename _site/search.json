[
  {
    "objectID": "VillegasJoseAlbertoU5-T1.html",
    "href": "VillegasJoseAlbertoU5-T1.html",
    "title": "Unidad 5. Algoritmos de intersecci√≥n y uni√≥n de conjuntos en el modelo de comparaci√≥n",
    "section": "",
    "text": "Jos√© Alberto Villegas D√≠az Disciplina"
  },
  {
    "objectID": "VillegasJoseAlbertoU5-T1.html#introducci√≥n",
    "href": "VillegasJoseAlbertoU5-T1.html#introducci√≥n",
    "title": "Unidad 5. Algoritmos de intersecci√≥n y uni√≥n de conjuntos en el modelo de comparaci√≥n",
    "section": "Introducci√≥n",
    "text": "Introducci√≥n\nConforme a Demaine, L√≥pez-Ortiz, y Munro (2000) dado un conjunto de \\(ùëò\\) listas ordenadas \\(ùê¥_{1}\\), \\(ùê¥_{2}\\), ‚Ä¶ ,\\(ùê¥_{k}\\) la intersecci√≥n consiste en un conjunto que contenga los elementos comunes a todas ellas. Para validar esto cada elemento de la intersecci√≥n debe estar presente en todas las listas (esto se prueba con comparaciones de igualdad).\nEn este reporte se evaluar√° el desempe√±o de algoritmos de intersecci√≥n de conjuntos representados mediante listas ordenadas de diferente tama√±o, considerando como par√°metros los m√©todos internos de b√∫squeda, el tama√±o de los conjuntos y la distribuci√≥n de sus elementos. El an√°lisis se realizar√° desde una perspectiva experimental, midiendo los costos en t√©rminos de tiempo de ejecuci√≥n y consumo de memoria. Se usar√°n gr√°ficos y tablas para cada conjunto de listas con el que se trabajar√°, para facilitar la comparaci√≥n de los algoritmos."
  },
  {
    "objectID": "VillegasJoseAlbertoU5-T1.html#carga-de-conjuntos",
    "href": "VillegasJoseAlbertoU5-T1.html#carga-de-conjuntos",
    "title": "Unidad 5. Algoritmos de intersecci√≥n y uni√≥n de conjuntos en el modelo de comparaci√≥n",
    "section": "Carga de Conjuntos",
    "text": "Carga de Conjuntos\nSe trabajar√° con los siguientes datos:\nConjunto \\(A\\) que contiene pares de listas.\nConjunto \\(B\\) que contiene tripletas de listas.\nConjunto \\(C\\) que contiene tuplas de 4 listas (tetrapleta).\n\nusing JSON\n\nA = JSON.parsefile(joinpath(homedir(), raw\"C:\\Users\\josea\\Downloads\\postinglists-for-intersection-A-k=2.json\\postinglists-for-intersection-A-k=2.json\"))\nB = JSON.parsefile(joinpath(homedir(), raw\"C:\\Users\\josea\\Downloads\\postinglists-for-intersection-B-k=3.json\\postinglists-for-intersection-B-k=3.json\"))\nC = JSON.parsefile(joinpath(homedir(), raw\"C:\\Users\\josea\\Downloads\\postinglists-for-intersection-C-k=4.json\\postinglists-for-intersection-C-k=4.json\"))\n\n200-element Vector{Any}:\n Any[Any[3, 4, 10, 17, 30, 38, 43, 49, 63, 66  ‚Ä¶  49863, 49869, 49882, 49883, 49905, 49943, 49963, 49965, 49986, 49987], Any[243, 1553, 1848, 1887, 1949, 2177, 2402, 2466, 2564, 3005  ‚Ä¶  48266, 48333, 48347, 48696, 48838, 49129, 49379, 49714, 49863, 49986], Any[1848, 3482, 3482, 3626, 4490, 4999, 7169, 7641, 7903, 8256  ‚Ä¶  46176, 46404, 46948, 47395, 47465, 47465, 47714, 48089, 48838, 49764], Any[4, 49, 91, 210, 237, 242, 318, 327, 353, 358  ‚Ä¶  48377, 48507, 48844, 48846, 49278, 49331, 49390, 49444, 49667, 49764]]\n Any[Any[43, 334, 367, 412, 493, 935, 1203, 1329, 1367, 1726  ‚Ä¶  48369, 48724, 48790, 48932, 49032, 49504, 49519, 49780, 49784, 49880], Any[13, 26, 42, 45, 132, 134, 150, 165, 172, 210  ‚Ä¶  49624, 49661, 49758, 49882, 49905, 49915, 49917, 49971, 49975, 49979], Any[43, 521, 1203, 1657, 2345, 2445, 2681, 3518, 3798, 4648  ‚Ä¶  45407, 45603, 46274, 46655, 47767, 48790, 49262, 49504, 49519, 49519], Any[2, 3, 7, 9, 11, 12, 15, 16, 18, 19  ‚Ä¶  49963, 49967, 49968, 49975, 49978, 49982, 49983, 49984, 49985, 49990]]\n Any[Any[196, 1192, 2220, 2220, 2530, 4735, 5655, 5766, 5828, 5828  ‚Ä¶  46896, 46931, 47424, 47613, 47640, 47713, 47846, 47942, 48825, 49232], Any[3, 12, 46, 224, 260, 262, 269, 272, 273, 281  ‚Ä¶  49862, 49863, 49864, 49876, 49897, 49937, 49949, 49974, 49981, 49992], Any[1, 2, 3, 4, 6, 8, 9, 10, 11, 12  ‚Ä¶  49989, 49990, 49991, 49993, 49994, 49996, 49997, 49998, 49999, 50000], Any[390, 446, 1104, 1192, 1474, 1747, 2530, 3441, 3716, 4518  ‚Ä¶  48565, 48715, 48825, 48830, 49232, 49232, 49348, 49801, 49850, 49897]]\n Any[Any[12, 26, 66, 102, 265, 270, 275, 285, 294, 297  ‚Ä¶  49888, 49891, 49904, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[649, 756, 835, 835, 1249, 1649, 2160, 2309, 2309, 2309  ‚Ä¶  44886, 45442, 46059, 46059, 47119, 47319, 47563, 48460, 48619, 49617], Any[2, 7, 11, 12, 18, 19, 20, 22, 28, 35  ‚Ä¶  48959, 49335, 49481, 49730, 49865, 49869, 49911, 49934, 49952, 49963], Any[556, 716, 759, 835, 1117, 1157, 1459, 1459, 1459, 1679  ‚Ä¶  48619, 48722, 49153, 49163, 49192, 49197, 49321, 49617, 49653, 49852]]\n Any[Any[461, 594, 677, 1158, 1159, 1363, 1556, 1766, 1812, 2117  ‚Ä¶  45377, 45788, 45895, 46976, 47314, 47569, 47627, 48627, 49852, 49917], Any[1158, 1302, 1812, 2129, 2873, 3082, 3082, 3173, 3173, 3283  ‚Ä¶  30587, 30587, 36082, 39276, 39698, 42287, 44488, 44694, 45225, 49852], Any[13, 26, 32, 42, 45, 89, 94, 134, 150, 157  ‚Ä¶  49877, 49882, 49905, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[68, 260, 262, 267, 269, 272, 273, 281, 282, 289  ‚Ä¶  37225, 39568, 39750, 42287, 42650, 43202, 44029, 45597, 46007, 46054]]\n Any[Any[13, 26, 32, 42, 45, 89, 94, 134, 150, 157  ‚Ä¶  49877, 49882, 49905, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[510, 834, 1130, 1139, 1170, 1532, 2316, 2559, 2719, 3077  ‚Ä¶  47430, 47484, 47840, 48261, 48285, 48495, 48585, 48594, 48599, 49631], Any[461, 1139, 1168, 1863, 2056, 2316, 2662, 2662, 2785, 2785  ‚Ä¶  46021, 46528, 47430, 47484, 48261, 48460, 48585, 48585, 48599, 48703], Any[12, 26, 66, 102, 265, 270, 275, 285, 294, 297  ‚Ä¶  49888, 49891, 49904, 49912, 49915, 49917, 49940, 49962, 49966, 49989]]\n Any[Any[1, 3, 6, 7, 12, 16, 18, 19, 27, 28  ‚Ä¶  49316, 49416, 49470, 49595, 49708, 49759, 49785, 49907, 49945, 49954], Any[19, 201, 443, 563, 580, 580, 1400, 1415, 1419, 1430  ‚Ä¶  41716, 41822, 42370, 42370, 42640, 43936, 44377, 44377, 44593, 48564], Any[25, 31, 32, 37, 52, 62, 66, 74, 91, 92  ‚Ä¶  49972, 49974, 49976, 49978, 49989, 49990, 49993, 49994, 49996, 49998], Any[19, 53, 107, 160, 201, 231, 443, 443, 509, 547  ‚Ä¶  40841, 42370, 42640, 43125, 43212, 43268, 44593, 47521, 48305, 49139]]\n Any[Any[13, 26, 32, 42, 45, 89, 94, 134, 150, 157  ‚Ä¶  49877, 49882, 49905, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[269, 1054, 2045, 2045, 2328, 3841, 4209, 4444, 4471, 5939  ‚Ä¶  48064, 48162, 48269, 48416, 48855, 48991, 49056, 49320, 49463, 49614], Any[777, 797, 797, 1158, 1272, 1411, 1411, 1444, 1494, 1644  ‚Ä¶  44173, 44753, 45589, 46343, 46343, 46465, 47034, 48874, 48991, 49614], Any[67, 125, 129, 153, 207, 233, 267, 268, 269, 299  ‚Ä¶  49901, 49910, 49936, 49937, 49939, 49951, 49953, 49958, 49963, 49976]]\n Any[Any[3, 12, 46, 224, 260, 262, 269, 272, 273, 281  ‚Ä¶  49862, 49863, 49864, 49876, 49897, 49937, 49949, 49974, 49981, 49992], Any[477, 573, 3673, 5311, 5883, 6152, 6327, 6411, 6411, 6703  ‚Ä¶  44302, 44937, 44937, 45286, 46019, 46306, 46540, 48213, 49149, 49951], Any[461, 474, 515, 1251, 1280, 2777, 3203, 3271, 3449, 3673  ‚Ä¶  48928, 48967, 48984, 49214, 49368, 49707, 49770, 49855, 49937, 49951], Any[67, 125, 129, 153, 207, 233, 267, 268, 269, 299  ‚Ä¶  49901, 49910, 49936, 49937, 49939, 49951, 49953, 49958, 49963, 49976]]\n Any[Any[13, 26, 42, 45, 132, 134, 150, 165, 172, 210  ‚Ä¶  49579, 49585, 49613, 49624, 49661, 49758, 49882, 49905, 49915, 49917], Any[1251, 1866, 3126, 3476, 3972, 4213, 5263, 5494, 5829, 5911  ‚Ä¶  48298, 48537, 48847, 48928, 48966, 48966, 48984, 49585, 49690, 49710], Any[1100, 1328, 2290, 2584, 2756, 2756, 2862, 3126, 3126, 3485  ‚Ä¶  46821, 47568, 48467, 48537, 49494, 49494, 49501, 49501, 49690, 49710], Any[67, 125, 129, 153, 207, 233, 267, 268, 269, 299  ‚Ä¶  49901, 49910, 49936, 49937, 49939, 49951, 49953, 49958, 49963, 49976]]\n Any[Any[12, 26, 66, 102, 265, 270, 275, 285, 294, 297  ‚Ä¶  49888, 49891, 49904, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[587, 971, 1128, 1625, 1625, 1854, 2632, 3456, 4297, 4815  ‚Ä¶  46305, 46575, 46575, 46642, 46938, 47121, 47575, 47575, 47575, 47622], Any[529, 654, 1128, 1166, 1196, 1776, 2099, 2632, 2826, 3117  ‚Ä¶  47121, 47162, 47288, 47575, 47694, 47794, 48357, 48422, 48887, 49114], Any[3, 4, 10, 17, 30, 38, 43, 49, 63, 66  ‚Ä¶  49863, 49869, 49882, 49883, 49905, 49943, 49963, 49965, 49986, 49987]]\n Any[Any[788, 869, 1112, 1188, 3002, 4000, 4000, 4141, 4141, 4247  ‚Ä¶  45827, 45904, 46030, 47101, 47101, 48328, 49007, 49007, 49048, 49598], Any[316, 355, 359, 380, 388, 389, 396, 429, 555, 558  ‚Ä¶  49301, 49312, 49359, 49463, 49466, 49565, 49634, 49727, 49744, 49969], Any[184, 325, 538, 667, 788, 790, 869, 1112, 1178, 1188  ‚Ä¶  48915, 49007, 49105, 49244, 49305, 49334, 49598, 49629, 49765, 49796], Any[5, 8, 12, 14, 20, 22, 24, 28, 29, 32  ‚Ä¶  49988, 49990, 49993, 49994, 49995, 49996, 49997, 49998, 49999, 50000]]\n Any[Any[260, 275, 294, 296, 314, 317, 341, 384, 457, 529  ‚Ä¶  49550, 49567, 49570, 49596, 49716, 49860, 49918, 49971, 49975, 49987], Any[262, 262, 681, 928, 1835, 3791, 3806, 3806, 3888, 4576  ‚Ä¶  42729, 43024, 43419, 43582, 44296, 44361, 44975, 45908, 46570, 46861], Any[681, 3443, 3806, 3888, 4970, 5038, 5120, 5132, 5210, 5330  ‚Ä¶  45134, 45177, 45471, 45497, 45908, 46016, 46611, 46861, 46922, 49716], Any[260, 262, 267, 269, 272, 273, 281, 282, 289, 294  ‚Ä¶  49173, 49301, 49415, 49423, 49461, 49478, 49619, 49715, 49813, 49840]]\n ‚ãÆ\n Any[Any[12, 26, 66, 102, 265, 270, 275, 285, 294, 297  ‚Ä¶  49888, 49891, 49904, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[270, 302, 322, 782, 2427, 3947, 3975, 4014, 4613, 4895  ‚Ä¶  47100, 47413, 47430, 47505, 47538, 47539, 47786, 48437, 49197, 49966], Any[701, 782, 1400, 2571, 2796, 2796, 3214, 3869, 3869, 3975  ‚Ä¶  45902, 45902, 46594, 46861, 46885, 46904, 46904, 47425, 47505, 47538], Any[12, 26, 66, 98, 102, 265, 270, 275, 285, 294  ‚Ä¶  49904, 49912, 49915, 49917, 49929, 49940, 49962, 49966, 49980, 49989]]\n Any[Any[45, 134, 165, 231, 234, 324, 353, 378, 378, 392  ‚Ä¶  45456, 45672, 45741, 46343, 46861, 46886, 47249, 48997, 49882, 49912], Any[25, 31, 32, 37, 52, 62, 66, 74, 91, 92  ‚Ä¶  49972, 49974, 49976, 49978, 49989, 49990, 49993, 49994, 49996, 49998], Any[134, 165, 353, 353, 515, 515, 612, 612, 627, 627  ‚Ä¶  44008, 44194, 45394, 46419, 46687, 46687, 46861, 46886, 47923, 48981], Any[13, 26, 32, 42, 45, 89, 94, 134, 150, 157  ‚Ä¶  49877, 49882, 49905, 49912, 49915, 49917, 49940, 49962, 49966, 49989]]\n Any[Any[660, 788, 1170, 1606, 2646, 2813, 2843, 3162, 3724, 3935  ‚Ä¶  46938, 47026, 47222, 47336, 47365, 47934, 49037, 49356, 49530, 49899], Any[13, 26, 32, 42, 45, 89, 94, 134, 150, 157  ‚Ä¶  49877, 49882, 49905, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[583, 1101, 1264, 1298, 1606, 2167, 2242, 2813, 3071, 3281  ‚Ä¶  42533, 42533, 44295, 44832, 45377, 45399, 46305, 46305, 46938, 49037], Any[12, 26, 66, 98, 102, 265, 270, 275, 285, 294  ‚Ä¶  49904, 49912, 49915, 49917, 49929, 49940, 49962, 49966, 49980, 49989]]\n Any[Any[13, 26, 32, 42, 45, 89, 94, 134, 150, 157  ‚Ä¶  49877, 49882, 49905, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[13, 26, 32, 42, 45, 89, 94, 134, 150, 157  ‚Ä¶  49877, 49882, 49905, 49912, 49915, 49917, 49940, 49962, 49966, 49989], Any[42, 345, 510, 616, 865, 1053, 1214, 1286, 1808, 1844  ‚Ä¶  46040, 46097, 46168, 46793, 46804, 46887, 47119, 47990, 49905, 49912], Any[42, 42, 89, 345, 353, 616, 1808, 2090, 2383, 2393  ‚Ä¶  35853, 35996, 36747, 38005, 39380, 41488, 45077, 46097, 46821, 49694]]\n Any[Any[2028, 2463, 3175, 3175, 3526, 3767, 4234, 4234, 4688, 5119  ‚Ä¶  45833, 45970, 47415, 47650, 48211, 48211, 48211, 48344, 48443, 49469], Any[12, 26, 66, 98, 102, 265, 270, 275, 285, 294  ‚Ä¶  49904, 49912, 49915, 49917, 49929, 49940, 49962, 49966, 49980, 49989], Any[2, 3, 7, 9, 11, 12, 15, 16, 18, 19  ‚Ä¶  49963, 49967, 49968, 49975, 49978, 49982, 49983, 49984, 49985, 49990], Any[130, 300, 1310, 1364, 1894, 1955, 1984, 2028, 2030, 2463  ‚Ä¶  48335, 48339, 48442, 48849, 49331, 49469, 49486, 49630, 49724, 49824]]\n Any[Any[273, 446, 785, 2468, 4235, 4499, 4518, 4923, 5112, 5135  ‚Ä¶  46921, 47618, 47775, 48090, 48201, 48218, 48382, 49226, 49861, 49981], Any[446, 653, 1097, 1097, 1237, 1237, 2145, 2145, 2468, 3758  ‚Ä¶  46788, 47766, 48218, 48581, 49209, 49226, 49226, 49797, 49861, 49861], Any[25, 31, 32, 37, 52, 62, 66, 74, 91, 92  ‚Ä¶  49972, 49974, 49976, 49978, 49989, 49990, 49993, 49994, 49996, 49998], Any[3, 12, 46, 224, 260, 262, 269, 272, 273, 281  ‚Ä¶  49862, 49863, 49864, 49876, 49897, 49937, 49949, 49974, 49981, 49992]]\n Any[Any[122, 521, 734, 743, 938, 1043, 1053, 1100, 1133, 1159  ‚Ä¶  48942, 48962, 49033, 49056, 49082, 49280, 49282, 49602, 49696, 49813], Any[293, 613, 659, 702, 1043, 1694, 1928, 2406, 2608, 2856  ‚Ä¶  45432, 45660, 47011, 47426, 47577, 47577, 48119, 48237, 49637, 49648], Any[293, 613, 659, 702, 722, 906, 939, 1234, 1249, 1270  ‚Ä¶  48119, 48133, 48453, 48974, 49392, 49414, 49489, 49637, 49648, 49931], Any[5, 8, 12, 14, 20, 22, 24, 28, 29, 32  ‚Ä¶  49988, 49990, 49993, 49994, 49995, 49996, 49997, 49998, 49999, 50000]]\n Any[Any[49, 162, 274, 308, 486, 503, 1556, 1779, 1807, 2155  ‚Ä¶  45631, 46025, 46069, 46099, 46537, 46848, 46928, 47702, 48696, 49179], Any[3, 4, 10, 17, 30, 38, 43, 49, 63, 66  ‚Ä¶  49863, 49869, 49882, 49883, 49905, 49943, 49963, 49965, 49986, 49987], Any[49, 308, 1617, 1617, 1630, 1630, 1630, 1700, 1830, 1850  ‚Ä¶  43148, 43342, 43656, 43747, 43747, 44123, 44680, 44844, 46025, 46099], Any[2, 7, 11, 12, 18, 19, 20, 22, 28, 35  ‚Ä¶  48959, 49335, 49481, 49730, 49865, 49869, 49911, 49934, 49952, 49963]]\n Any[Any[64, 137, 287, 831, 1090, 1509, 1784, 2158, 2275, 2484  ‚Ä¶  48067, 48328, 48450, 48596, 49018, 49106, 49230, 49583, 49701, 49977], Any[25, 31, 32, 37, 52, 62, 66, 74, 91, 92  ‚Ä¶  49972, 49974, 49976, 49978, 49989, 49990, 49993, 49994, 49996, 49998], Any[5, 8, 12, 14, 20, 22, 24, 28, 29, 32  ‚Ä¶  49988, 49990, 49993, 49994, 49995, 49996, 49997, 49998, 49999, 50000], Any[25, 32, 137, 1784, 2329, 2329, 2602, 3332, 3553, 3553  ‚Ä¶  47511, 47666, 47679, 47921, 47966, 48057, 48156, 49018, 49783, 49791]]\n Any[Any[10, 13, 14, 15, 21, 25, 27, 30, 36, 40  ‚Ä¶  49806, 49835, 49839, 49857, 49877, 49884, 49889, 49926, 49930, 49943], Any[101, 157, 161, 220, 351, 514, 523, 544, 601, 631  ‚Ä¶  46117, 46390, 46480, 46559, 46615, 46908, 47297, 47419, 48801, 49276], Any[13, 26, 42, 45, 132, 134, 150, 165, 172, 210  ‚Ä¶  49624, 49661, 49758, 49882, 49905, 49915, 49917, 49971, 49975, 49979], Any[544, 884, 1152, 1516, 1601, 1772, 2036, 2117, 2143, 2143  ‚Ä¶  41580, 41719, 42068, 42461, 43031, 43179, 46117, 46887, 47505, 48289]]\n Any[Any[10, 133, 306, 347, 475, 525, 796, 971, 1148, 1148  ‚Ä¶  45198, 45198, 45859, 45859, 46242, 46901, 48079, 48176, 48509, 48677], Any[306, 475, 576, 651, 796, 822, 857, 971, 1267, 1344  ‚Ä¶  46916, 47320, 47555, 48176, 48509, 48677, 49066, 49145, 49179, 49965], Any[10, 13, 14, 15, 21, 25, 27, 30, 36, 40  ‚Ä¶  49806, 49835, 49839, 49857, 49877, 49884, 49889, 49926, 49930, 49943], Any[3, 4, 10, 17, 30, 38, 43, 49, 63, 66  ‚Ä¶  49863, 49869, 49882, 49883, 49905, 49943, 49963, 49965, 49986, 49987]]\n Any[Any[4, 49, 91, 210, 237, 242, 318, 327, 353, 358  ‚Ä¶  48377, 48507, 48844, 48846, 49278, 49331, 49390, 49444, 49667, 49764], Any[654, 654, 1302, 2319, 2319, 3767, 3961, 4203, 4547, 4912  ‚Ä¶  46828, 47012, 47179, 47441, 47614, 48594, 49652, 49817, 49817, 49817], Any[12, 26, 66, 98, 102, 265, 270, 275, 285, 294  ‚Ä¶  49904, 49912, 49915, 49917, 49929, 49940, 49962, 49966, 49980, 49989], Any[285, 324, 654, 654, 834, 1103, 1128, 1302, 1654, 1654  ‚Ä¶  48422, 48460, 48516, 48594, 49114, 49159, 49652, 49678, 49817, 49877]]"
  },
  {
    "objectID": "VillegasJoseAlbertoU5-T1.html#algortimo-melding-me",
    "href": "VillegasJoseAlbertoU5-T1.html#algortimo-melding-me",
    "title": "Unidad 5. Algoritmos de intersecci√≥n y uni√≥n de conjuntos en el modelo de comparaci√≥n",
    "section": "Algortimo Melding \\((ME)\\)",
    "text": "Algortimo Melding \\((ME)\\)\nBaeza-Yates (2004, 2005) se√±ala al \\(\\textit{merging}\\) como uno de los m√©todos cl√°sicos para calcular la intersecci√≥n de conjuntos ordenados, con una complejidad como se muestra:\nComplejidad:\nBaeza-Yates (2004, 2005) destaca que la fusi√≥n tradicional (como la que se usa en el algoritmo MergeSort) requiere \\(O(n+m)\\) comparaciones en el peor caso, donde \\(n\\) y \\(m\\) son los tama√±os de los dos conjuntos ordenados \\(D\\) y \\(Q\\). Esto es √≥ptimo cuando \\(n‚âàm\\), pero ineficiente cuando \\(n‚â´m\\) (es decir; intersectar una lista grande con una peque√±a).\nSe tiene que tener en consideraci√≥n que una de las limitantes de este algoritmo es siempre inspecciona todos los elementos de ambas listas, incluso si no hay superposici√≥n.\n\nPlan de implementaci√≥n\n\nSe definir√° una funci√≥n base para realizar la intersecci√≥n de dos conjuntos por \\(ME\\)\nSe definir√°n funciones de soporte que nos permitir√°n procesar los datos en funci√≥n del tipo de conjunto ( Para pares, tripletas y cuadruples de listas)\nSe definir√° una funci√≥n para computar todas las intersecciones. Esta, a su vez, generar√° un reporte con m√©tricas para medir el desempe√±o del algoritmo, como; tiempo de ejecuci√≥n, n√∫mero de comparaciones y las longitudes de las intersecciones para cada conjunto de datos.\n\n\n# Funci√≥n base para intersecci√≥n de dos listas\nfunction intersect_two!(result, A, B)\n    i = j = 1\n    m, n = length(A), length(B)\n    \n    @inbounds while i &lt;= m && j &lt;= n\n        a, b = A[i], B[j]\n        if a == b\n            push!(result, a)\n            i += 1\n            j += 1\n        elseif a &lt; b\n            i += 1\n        else\n            j += 1\n        end\n    end\n    \n    result\nend  \n\nintersect_two! (generic function with 1 method)\n\n\n\n# Funci√≥n para pares de listas (Conjunto A) \nfunction intersect_pairs(pairs_list)\n    results = []\n    total_comparisons = 0\n    total_time = 0.0\n    total_result_length = 0  \n    \n    for (A, B) in pairs_list\n        result = Int[]\n        time_taken = @elapsed begin\n            comparisons = intersect_two_count!(result, A, B)\n        end\n        \n        push!(results, IntersectionResult(result, comparisons, time_taken))\n        total_comparisons += comparisons\n        total_time += time_taken\n        total_result_length += length(result)  # Sumamos la longitud de este resultado\n    end\n    \n    (results=results, total_comparisons=total_comparisons, \n     total_time=total_time, total_result_length=total_result_length)\nend\n\n# Funci√≥n para tripletas de listas (Conjunto B) \nfunction intersect_triplets(triplets_list)\n    results = []\n    total_comparisons = 0\n    total_time = 0.0\n    total_result_length = 0  \n    \n    for (A, B, C) in triplets_list\n        temp = Int[]\n        time_taken1 = @elapsed comp1 = intersect_two_count!(temp, A, B)\n        \n        result = Int[]\n        time_taken2 = @elapsed comp2 = intersect_two_count!(result, temp, C)\n        \n        total_comp = comp1 + comp2\n        total_time_taken = time_taken1 + time_taken2\n        \n        push!(results, IntersectionResult(result, total_comp, total_time_taken))\n        total_comparisons += total_comp\n        total_time += total_time_taken\n        total_result_length += length(result)  # Sumamos la longitud de este resultado\n    end\n    \n    (results=results, total_comparisons=total_comparisons,\n     total_time=total_time, total_result_length=total_result_length)\nend\n\n# Funci√≥n para cu√°druples de listas (Conjunto C) \nfunction intersect_quadruples(quadruples_list)\n    results = []\n    total_comparisons = 0\n    total_time = 0.0\n    total_result_length = 0  \n    \n    for (A, B, C, D) in quadruples_list\n        temp1 = Int[]\n        time_taken1 = @elapsed comp1 = intersect_two_count!(temp1, A, B)\n        \n        temp2 = Int[]\n        time_taken2 = @elapsed comp2 = intersect_two_count!(temp2, temp1, C)\n        \n        result = Int[]\n        time_taken3 = @elapsed comp3 = intersect_two_count!(result, temp2, D)\n        \n        total_comp = comp1 + comp2 + comp3\n        total_time_taken = time_taken1 + time_taken2 + time_taken3\n        \n        push!(results, IntersectionResult(result, total_comp, total_time_taken))\n        total_comparisons += total_comp\n        total_time += total_time_taken\n        total_result_length += length(result)  # Sumamos la longitud de este resultado\n    end\n    \n    (results=results, total_comparisons=total_comparisons,\n     total_time=total_time, total_result_length=total_result_length)\nend\n\nintersect_quadruples (generic function with 1 method)\n\n\n\n# Funci√≥n general \nfunction compute_all_intersections(pairs_A, triplets_B, quadruples_C)\n    println(\"Procesando Conjunto A (pares)...\")\n    result_A = intersect_pairs(pairs_A)\n    \n    println(\"\\nProcesando Conjunto B (tripletas)...\")\n    result_B = intersect_triplets(triplets_B)\n    \n    println(\"\\nProcesando Conjunto C (cu√°druples)...\")\n    result_C = intersect_quadruples(quadruples_C)\n    \n    # Crear reporte resumido actualizado\n    report = \"\"\"\n    RESUMEN DE RESULTADOS:\n    \n    CONJUNTO A (PARES):\n    - Total de pares procesados: $(length(pairs_A))\n    - Comparaciones totales: $(result_A.total_comparisons)\n    - Tiempo total (s): $(round(result_A.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_A.total_result_length)\n    - Longitud promedio por resultado: $(round(result_A.total_result_length/length(pairs_A), digits=2))\n    \n    CONJUNTO B (TRIPLETAS):\n    - Total de tripletas procesadas: $(length(triplets_B))\n    - Comparaciones totales: $(result_B.total_comparisons)\n    - Tiempo total (s): $(round(result_B.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_B.total_result_length)\n    - Longitud promedio por resultado: $(round(result_B.total_result_length/length(triplets_B), digits=2))\n    \n    CONJUNTO C (CU√ÅDRUPLES):\n    - Total de cu√°druples procesadas: $(length(quadruples_C))\n    - Comparaciones totales: $(result_C.total_comparisons)\n    - Tiempo total (s): $(round(result_C.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_C.total_result_length)\n    - Longitud promedio por resultado: $(round(result_C.total_result_length/length(quadruples_C), digits=2))\n    \"\"\"\n    \n    println(report)\n    \n    (result_A, result_B, result_C, report)\nend\n\ncompute_all_intersections (generic function with 1 method)\n\n\n\ncompute_all_intersections(A, B, C)\n\nProcesando Conjunto A (pares)...\n\nProcesando Conjunto B (tripletas)...\n\nProcesando Conjunto C (cu√°druples)...\nRESUMEN DE RESULTADOS:\n\nCONJUNTO A (PARES):\n- Total de pares procesados: 200\n- Comparaciones totales: 3238899\n- Tiempo total (s): 0.072497\n- Suma de longitudes de resultados: 3627\n- Longitud promedio por resultado: 18.14\n\nCONJUNTO B (TRIPLETAS):\n- Total de tripletas procesadas: 200\n- Comparaciones totales: 5276587\n- Tiempo total (s): 0.131184\n- Suma de longitudes de resultados: 4723\n- Longitud promedio por resultado: 23.62\n\nCONJUNTO C (CU√ÅDRUPLES):\n- Total de cu√°druples procesadas: 200\n- Comparaciones totales: 4261034\n- Tiempo total (s): 0.221043\n- Suma de longitudes de resultados: 1550\n- Longitud promedio por resultado: 7.75\n\n\n\n((results = Any[IntersectionResult([6323, 12498], 42938, 0.0009946), IntersectionResult([21109, 37491, 38824, 40060, 43252, 48615], 6402, 0.0001619), IntersectionResult([10441], 4725, 0.000119), IntersectionResult([227, 2802, 3122, 3220, 35566, 38126, 38679, 39587, 39971, 40488, 40976, 41053, 41367, 46954, 46955, 49582], 8930, 0.0002035), IntersectionResult([4850, 11205, 20287, 23256, 29729], 6621, 0.0001474), IntersectionResult([4399, 5450, 10487, 25589], 6156, 0.0001411), IntersectionResult([5194, 6030, 7380, 7932, 12040, 12583, 14811], 4615, 0.0001061), IntersectionResult([2729, 10222, 13543, 23966, 29304, 36381, 42776], 8127, 0.0001835), IntersectionResult([337, 573, 676, 782, 1175, 1196, 1279, 3126, 3767, 4358  ‚Ä¶  42994, 43453, 43723, 44271, 44433, 44447, 44492, 44639, 45051, 47320], 78056, 0.0017294), IntersectionResult([9008, 15039, 20863, 20870, 24643, 31997, 32817], 5891, 0.0001338)  ‚Ä¶  IntersectionResult([533, 2342, 4110, 6373, 6845, 11165, 14145, 14159, 14192, 14217  ‚Ä¶  36901, 37631, 39409, 42585, 42596, 45398, 45528, 47346, 47669, 47924], 29106, 0.0005912), IntersectionResult([12189, 39789, 40618], 4777, 0.0001004), IntersectionResult([1851, 2533, 2756, 2814, 8897, 17536], 4674, 9.67e-5), IntersectionResult([2673, 3189, 3275, 3565, 3729, 3897, 4486, 5944, 9708, 9731  ‚Ä¶  40963, 41278, 41469, 41530, 43418, 43965, 47263, 48515, 49005, 49175], 81246, 0.001686), IntersectionResult([5917, 5953, 6004, 6416, 7946, 9841, 12491, 22944, 46097], 4757, 0.0001015), IntersectionResult([613, 1244, 1871, 2271, 2893, 2908, 3296, 3559, 7308, 8196  ‚Ä¶  33616, 35432, 36646, 37509, 39507, 41946, 43243, 44808, 44973, 49738], 42755, 0.0008775), IntersectionResult([15521, 21090, 22638], 7413, 0.0001538), IntersectionResult([1097, 2487, 2503, 2770, 8216, 17669, 42376], 7863, 0.0001666), IntersectionResult([5363, 8739, 12242, 14529, 24924], 8025, 0.0001737), IntersectionResult([1686, 6265, 9541, 14340, 43083, 43183, 44310, 44481, 46206], 8181, 0.0001718)], total_comparisons = 3238899, total_time = 0.0724968, total_result_length = 3627), (results = Any[IntersectionResult([5239, 6162, 6806, 7411, 8951, 11279], 9652, 0.0002813), IntersectionResult([5204, 5250, 6571, 8505, 21631, 30697, 36071], 46257, 0.0010402), IntersectionResult([585, 1097, 2368, 8929, 11134, 11776, 14196, 14258, 17611, 24256, 26851, 27931, 37075, 37350, 37463, 49091], 49451, 0.0011871), IntersectionResult([4961, 20059, 40091, 40106], 14690, 0.00041190000000000004), IntersectionResult([46886], 8509, 0.0002148), IntersectionResult([314, 384, 675, 759, 2559, 3509, 4149, 4812, 5190, 5210  ‚Ä¶  45352, 45363, 45413, 45425, 45841, 46153, 47235, 48086, 49596, 49716], 47791, 0.0011094), IntersectionResult([4273, 4702, 5081, 5122, 5145, 5311, 5330, 5366, 6409, 6532  ‚Ä¶  45007, 45284, 45330, 45734, 46040, 46048, 46127, 46751, 47542, 49570], 35306, 0.0008248000000000001), IntersectionResult([297, 731, 743, 777, 936, 977, 1214, 1461, 1468, 1617  ‚Ä¶  44421, 45059, 45357, 45480, 46861, 47523, 49114, 49404, 49915, 49917], 6700, 0.000281), IntersectionResult([656, 745, 1256, 1783, 1948, 2080, 2156, 2202, 2624, 2749  ‚Ä¶  46040, 47368, 48106, 48710, 48928, 48967, 49076, 49214, 49229, 49593], 110930, 0.0026601999999999997), IntersectionResult([4997, 5223, 5439, 5564, 5655, 5797, 6010, 6028, 6056, 6186  ‚Ä¶  6591, 6616, 6675, 6811, 7033, 10701, 12741, 17305, 30237, 34502], 9868, 0.0002559)  ‚Ä¶  IntersectionResult([291, 738, 1196, 1234, 2041, 2050, 6757, 11740, 14447, 15428, 38763, 49954], 50757, 0.0014661000000000001), IntersectionResult([15287, 42767], 14094, 0.00036950000000000004), IntersectionResult([2316, 12774, 12838, 18103, 23914, 27715, 40838, 44982], 12304, 0.0003034), IntersectionResult([275, 1494, 1979, 2508, 19085, 21630, 28195, 36747], 12335, 0.0003372), IntersectionResult([2703, 6305, 7111, 15456, 46674], 12994, 0.0003548), IntersectionResult([36813, 45326], 32195, 0.0007241000000000001), IntersectionResult([7418, 18463, 23704, 26896, 30677, 30977, 35574, 35602, 36832, 39841, 40630], 70694, 0.0020865000000000002), IntersectionResult([2909, 13712, 22475, 23606, 31618, 35409, 38102, 38625, 42221, 48249], 34057, 0.0007616), IntersectionResult([15517, 33999], 30980, 0.0009181), IntersectionResult([1196, 2728, 2991, 3126, 3518, 5661, 5911, 6009, 6205, 6470  ‚Ä¶  9513, 10155, 10441, 11787, 12583, 14361, 16645, 17346, 21983, 29133], 8393, 0.0002117)], total_comparisons = 5276587, total_time = 0.13118379999999996, total_result_length = 4723), (results = Any[IntersectionResult(Int64[], 9854, 0.0002651), IntersectionResult([41697, 41975], 27522, 0.0008225999999999999), IntersectionResult([1192, 2530, 5655, 5766, 5828, 6462, 6515, 6811, 7041, 7253  ‚Ä¶  44370, 44477, 44663, 45924, 46455, 46561, 46931, 47846, 47942, 48825], 88125, 0.002637), IntersectionResult([2309, 2334, 2826], 9895, 0.0002759), IntersectionResult([4977, 5111, 9073, 9952], 7130, 0.0002248), IntersectionResult([2316, 5316, 5711, 6001, 7323, 8792, 9122, 9960, 10143, 10804, 11383, 11783, 16430, 17256, 17517, 20413, 20787, 32079, 46528], 10093, 0.0002787), IntersectionResult([201, 443, 1903, 2568, 3571, 8904, 12928, 18489, 21396, 21644, 27378], 20364, 0.0006012), IntersectionResult([9117, 14353, 41555], 9788, 0.0002634), IntersectionResult([8289, 12366, 16834, 31510, 33936], 10551, 0.00027289999999999997), IntersectionResult(Int64[], 2827, 6.7e-5)  ‚Ä¶  IntersectionResult([5743, 6042, 6720, 9994, 10879, 10898, 11978, 17668, 18037, 18504, 28427, 45377], 11336, 0.00028379999999999996), IntersectionResult([42, 345, 616, 1808, 2090, 2795, 3133, 3912, 5039, 5240  ‚Ä¶  23904, 26098, 26870, 28427, 29213, 33474, 35853, 35996, 36747, 46097], 7105, 0.00024270000000000002), IntersectionResult(Int64[], 35896, 0.0009747), IntersectionResult([11327, 32778, 46318, 48218, 49861], 20305, 0.0005597), IntersectionResult([2406, 4010, 23082, 25325, 37211, 41584, 42416, 44598, 44599], 42430, 0.0011412), IntersectionResult([2466, 23191, 24711, 27172, 38942], 10897, 0.0002561), IntersectionResult([15601, 22028, 27245, 30117, 30251, 47966, 49018], 56039, 0.001433), IntersectionResult([28029], 10867, 0.0002491), IntersectionResult([1530, 2956, 22833, 39553], 13776, 0.00037810000000000003), IntersectionResult(Int64[], 8461, 0.0002175)], total_comparisons = 4261034, total_time = 0.2210433000000001, total_result_length = 1550), \"RESUMEN DE RESULTADOS:\\n\\nCONJUNTO A (PARES):\\n- Total de pares procesados: 200\\n- Comparaciones totales: 3238899\\n- Tiempo total (s): 0.072497\\n- Suma de longitudes de resultados: 3627\\n- Longitud promedio por resultado: 18.14\\n\\nCONJUNTO B (TRIPLETAS):\\n- Total de tripletas procesadas: 200\\n- Comparaciones totales: 5276587\\n- Tiempo total (s): 0.131184\\n- Suma de longitudes de resultados: 4723\\n- Longitud promedio por resultado: 23.62\\n\\nCONJUNTO C (CU√ÅDRUPLES):\\n- Total de cu√°druples procesadas: 200\\n- Comparaciones totales: 4261034\\n- Tiempo total (s): 0.221043\\n- Suma de longitudes de resultados: 1550\\n- Longitud promedio por resultado: 7.75\\n\")"
  },
  {
    "objectID": "VillegasJoseAlbertoU5-T1.html#algortimo-baeza-yates-by",
    "href": "VillegasJoseAlbertoU5-T1.html#algortimo-baeza-yates-by",
    "title": "Unidad 5. Algoritmos de intersecci√≥n y uni√≥n de conjuntos en el modelo de comparaci√≥n",
    "section": "Algortimo Baeza-Yates \\((BY)\\)",
    "text": "Algortimo Baeza-Yates \\((BY)\\)\nBaeza-Yates (2004) propone un algoritmo innovador que optimiza la intersecci√≥n de conjuntos, superando en eficiencia a m√©todos tradicionales como la fusi√≥n lineal (merging) o la b√∫squeda binaria m√∫ltiple, es especialmente √∫til en escenarios donde los tama√±os de los conjuntos difieren significativamente. Un algoritmo cl√°sico como la fusi√≥n lineal tiene complejidad \\(O(n+m)\\) , lo que resulta ineficiente cuando \\(n‚â´m\\).\nEl algoritmo combina estrategias de divide y vencer√°s y b√∫squeda binaria para:\n\nAdaptarse din√°micamente al tama√±o de los conjuntos, priorizando la lista m√°s peque√±a (Q) para minimizar comparaciones.\nRecursivamente dividir el problema alrededor de la mediana de Q, buscando su posici√≥n en D mediante b√∫squeda binaria.\nDescartar r√°pidamente subconjuntos sin superposici√≥n, reduciendo el espacio de b√∫squeda\n\nComplejidad:\n\nPeor caso: \\(O(mlogn)\\) (similar a \\(m\\) b√∫squedas binarias)\nCaso promedio: Mejor que \\(m+n\\) (merge) cuando \\(n‚â´m\\).\nMejor caso: \\(O(log^2n)\\) (si no hay intersecci√≥n)\n\n\nPlan de implementaci√≥n\n\nPara este reporte se adem√°s de la b√∫squeda binaria propuesta en el algoritmo Baeza-Yates (2004), se buscar√° parametrizar \\(BY\\) para los siguientes algoritmos de b√∫squeda: B√∫squeda no acotada \\(B_{1}\\) (Exponencial) y B√∫squeda no acotada \\(B_{2}\\) (Doblemente doblada). En ese sentido, en primer lugar, se definir√°n las funciones de b√∫squeda con las que se parametrizar√° el algoritmo.\nSe definir√° una funci√≥n base para realizar la intersecci√≥n de dos conjuntos por \\(BY\\)\nSe definir√°n funciones de soporte que nos permitir√°n procesar los datos en funci√≥n del tipo de conjunto ( Para pares, tripletas y cuadruples de listas)\nSe definir√° una funci√≥n para computar todas las intersecciones. Esta, a su vez, generar√° un reporte con m√©tricas para medir el desempe√±o del algoritmo, como; tiempo de ejecuci√≥n, n√∫mero de comparaciones y las longitudes de las intersecciones para cada conjunto de datos. Tambi√©n permitir√° indicar el nombre del algoritmo de b√∫squeda con el que se realizar√° el ordenamiento.\n\n\n#Definici√≥n de los algoritmos de b√∫squeda para la parametrizaci√≥n de BY\n\n# B√∫squeda binaria\nfunction binary_search(arr::Vector{Int}, x::Int, start::Int, counter::Base.RefValue{Int}=Ref(0))\n    low, high = start, length(arr)\n    while low &lt;= high\n        mid = (low + high) √∑ 2\n        counter[] += 1\n        if arr[mid] == x\n            return mid\n        elseif arr[mid] &lt; x\n            low = mid + 1\n        else\n            high = mid - 1\n        end\n    end\n    return low\nend\n\n# B√∫squeda exponencial(B1)\nfunction exponential_search(arr::Vector{Int}, x::Int, start::Int, counter::Base.RefValue{Int}=Ref(0))\n    n = length(arr)\n    if start &gt; n\n        return n + 1\n    end\n    if arr[start] == x\n        counter[] += 1\n        return start\n    end\n    i = 1\n    while (start + i &lt;= n) && (arr[start + i] &lt; x)\n        counter[] += 1\n        i *= 2\n    end\n    low = start + (i √∑ 2)\n    high = min(start + i, n)\n    while low &lt;= high\n        mid = (low + high) √∑ 2\n        counter[] += 1\n        if arr[mid] == x\n            return mid\n        elseif arr[mid] &lt; x\n            low = mid + 1\n        else\n            high = mid - 1\n        end\n    end\n    return low\nend\n\n# B√∫squeda doblemente doblada (B2)\nfunction doubling_search(arr::Vector{Int}, x::Int, start::Int, counter::Base.RefValue{Int}=Ref(0))\n    n = length(arr)\n    idx = start\n\n    if idx &lt;= n && arr[idx] == x\n        counter[] += 1\n        return idx\n    end\n\n    i = 1\n    while (idx + i &lt;= n) && (arr[idx + i] &lt; x)\n        counter[] += 1\n        i *= 2\n    end\n\n    low = idx + (i √∑ 2)\n    high = min(idx + i, n)\n\n    while low &lt;= high\n        mid = (low + high) √∑ 2\n        counter[] += 1\n        if arr[mid] == x\n            return mid\n        elseif arr[mid] &lt; x\n            low = mid + 1\n        else\n            high = mid - 1\n        end\n    end\n\n    return low\nend\n\ndoubling_search (generic function with 2 methods)\n\n\n\nfunction baezayates!(\n    output::Vector{Int},\n    A::Vector{Int}, a_sp::Int, a_ep::Int,\n    B::Vector{Int}, b_sp::Int, b_ep::Int,\n    findpos::Function,\n    comps::Base.RefValue{Int}\n)\n    (a_ep &lt; a_sp || b_ep &lt; b_sp) && return output\n    imedian = (a_sp + a_ep) √∑ 2\n    median = A[imedian]\n    medpos = min(findpos(B, median, b_sp, comps), b_ep)\n\n    matches = median == B[medpos]\n    baezayates!(output, A, a_sp, imedian - 1, B, b_sp, medpos - matches, findpos, comps)\n    matches && push!(output, median)\n    baezayates!(output, A, imedian + 1, a_ep, B, medpos + matches, b_ep, findpos, comps)\n    return output\nend\n\nfunction baezayates!(output::Vector{Int}, A::Vector{Int}, B::Vector{Int}, findpos::Function)\n    comps = Ref(0)\n    baezayates!(output, A, 1, length(A), B, 1, length(B), findpos, comps)\n    return comps[]\nend\n\nbaezayates! (generic function with 7 methods)\n\n\n\nstruct IntersectionResultby\n    result::Vector{Int}\n    comparisons::Int\n    time_taken::Float64\nend\n\nfunction intersect_baeza_yates_recursive!(result::Vector{Int}, lists::Vector{Vector{Int}}, findpos::Function)\n    comparisons = 0\n    sorted_lists = sort(lists, by=length)\n    base_list = sorted_lists[1]\n    for i in 2:length(sorted_lists)\n        new_result = Int[]\n        comps = baezayates!(new_result, base_list, sorted_lists[i], findpos)\n        comparisons += comps\n        base_list = new_result\n        if isempty(base_list)\n            break\n        end\n    end\n    append!(result, base_list)\n    return comparisons\nend\n\nfunction intersect_baeza_groups_general(groups, findpos::Function)\n    results = []\n    total_comparisons = 0\n    total_time = 0.0\n    total_result_length = 0\n\n    for group in groups\n        result = Int[]\n        time_taken = @elapsed begin\n            comparisons = intersect_baeza_yates_recursive!(result, [Vector{Int}(x) for x in group], findpos)\n            total_comparisons += comparisons\n            total_result_length += length(result)\n        end\n        push!(results, IntersectionResultby(result, comparisons, time_taken))\n        total_time += time_taken\n    end\n\n    return (\n        results=results,\n        total_comparisons=total_comparisons,\n        total_time=total_time,\n        total_result_length=total_result_length\n    )\nend\n\nintersect_baeza_groups_general (generic function with 1 method)\n\n\n\n# Funci√≥n general para procesar todos los conjuntos y generar reporte\nfunction compute_all_intersections_baeza_custom(pairs_A, triplets_B, quadruples_C, findpos::Function, metodo::String)\n    println(\"Procesando Conjunto A (pares) con Baeza-Yates y b√∫squeda $metodo...\")\n    result_A = intersect_baeza_groups_general(pairs_A, findpos)\n\n    println(\"\\nProcesando Conjunto B (tripletas) con Baeza-Yates y b√∫squeda $metodo...\")\n    result_B = intersect_baeza_groups_general(triplets_B, findpos)\n\n    println(\"\\nProcesando Conjunto C (cu√°druples) con Baeza-Yates y b√∫squeda $metodo...\")\n    result_C = intersect_baeza_groups_general(quadruples_C, findpos)\n\n    report = \"\"\"\n    RESUMEN DE RESULTADOS (BAEZA-YATES CON B√öSQUEDA $metodo):\n\n    CONJUNTO A (PARES):\n    - Total de pares procesados: $(length(pairs_A))\n    - Comparaciones totales: $(result_A.total_comparisons)\n    - Tiempo total (s): $(round(result_A.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_A.total_result_length)\n    - Longitud promedio por resultado: $(round(result_A.total_result_length / max(length(pairs_A),1), digits=2))\n\n    CONJUNTO B (TRIPLETAS):\n    - Total de tripletas procesadas: $(length(triplets_B))\n    - Comparaciones totales: $(result_B.total_comparisons)\n    - Tiempo total (s): $(round(result_B.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_B.total_result_length)\n    - Longitud promedio por resultado: $(round(result_B.total_result_length / max(length(triplets_B),1), digits=2))\n\n    CONJUNTO C (CU√ÅDRUPLES):\n    - Total de cu√°druples procesadas: $(length(quadruples_C))\n    - Comparaciones totales: $(result_C.total_comparisons)\n    - Tiempo total (s): $(round(result_C.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_C.total_result_length)\n    - Longitud promedio por resultado: $(round(result_C.total_result_length / max(length(quadruples_C),1), digits=2))\n    \"\"\"\n\n    println(report)\n    return (result_A, result_B, result_C, report)\nend\n\ncompute_all_intersections_baeza_custom (generic function with 1 method)\n\n\n\ncompute_all_intersections_baeza_custom(A, B, C, binary_search, \"Binaria\")\n\nProcesando Conjunto A (pares) con Baeza-Yates y b√∫squeda Binaria...\n\nProcesando Conjunto B (tripletas) con Baeza-Yates y b√∫squeda Binaria...\n\nProcesando Conjunto C (cu√°druples) con Baeza-Yates y b√∫squeda Binaria...\nRESUMEN DE RESULTADOS (BAEZA-YATES CON B√öSQUEDA Binaria):\n\nCONJUNTO A (PARES):\n- Total de pares procesados: 200\n- Comparaciones totales: 236662\n- Tiempo total (s): 0.687597\n- Suma de longitudes de resultados: 3627\n- Longitud promedio por resultado: 18.14\n\nCONJUNTO B (TRIPLETAS):\n- Total de tripletas procesadas: 200\n- Comparaciones totales: 478929\n- Tiempo total (s): 0.305697\n- Suma de longitudes de resultados: 4723\n- Longitud promedio por resultado: 23.62\n\nCONJUNTO C (CU√ÅDRUPLES):\n- Total de cu√°druples procesadas: 200\n- Comparaciones totales: 270415\n- Tiempo total (s): 0.244972\n- Suma de longitudes de resultados: 1550\n- Longitud promedio por resultado: 7.75\n\n\n\n((results = Any[IntersectionResultby([6323, 12498], 1584, 0.1633762), IntersectionResultby([21109, 37491, 38824, 40060, 43252, 48615], 1179, 0.000518), IntersectionResultby([10441], 935, 0.0003726), IntersectionResultby([227, 2802, 3122, 3220, 35566, 38126, 38679, 39587, 39971, 40488, 40976, 41053, 41367, 46954, 46955, 49582], 1091, 0.0008286), IntersectionResultby([4850, 11205, 20287, 23256, 29729], 1148, 0.0006772), IntersectionResultby([4399, 5450, 10487, 25589], 1324, 0.0005932), IntersectionResultby([5194, 6030, 7380, 7932, 12040, 12583, 14811], 1122, 0.0002404), IntersectionResultby([2729, 10222, 13543, 23966, 29304, 36381, 42776], 1071, 0.0007421), IntersectionResultby([337, 573, 676, 782, 1175, 1196, 1279, 3126, 3767, 4358  ‚Ä¶  42994, 43453, 43723, 44271, 44433, 44447, 44492, 44639, 45051, 47320], 1710, 0.0055981), IntersectionResultby([9008, 15039, 20863, 20870, 24643, 31997, 32817], 1131, 0.0003867)  ‚Ä¶  IntersectionResultby([533, 2342, 4110, 6373, 6845, 11165, 14145, 14159, 14192, 14217  ‚Ä¶  36901, 37631, 39409, 42585, 42596, 45398, 45528, 47346, 47669, 47924], 1499, 0.0014745), IntersectionResultby([12189, 39789, 40618], 1061, 0.0002145), IntersectionResultby([1851, 2533, 2756, 2814, 8897, 17536], 953, 0.0002063), IntersectionResultby([2673, 3189, 3275, 3565, 3729, 3897, 4486, 5944, 9708, 9731  ‚Ä¶  40963, 41278, 41469, 41530, 43418, 43965, 47263, 48515, 49005, 49175], 1553, 0.0039977), IntersectionResultby([5917, 5953, 6004, 6416, 7946, 9841, 12491, 22944, 46097], 1106, 0.0002573), IntersectionResultby([613, 1244, 1871, 2271, 2893, 2908, 3296, 3559, 7308, 8196  ‚Ä¶  33616, 35432, 36646, 37509, 39507, 41946, 43243, 44808, 44973, 49738], 1446, 0.0025071), IntersectionResultby([15521, 21090, 22638], 1229, 0.000356), IntersectionResultby([1097, 2487, 2503, 2770, 8216, 17669, 42376], 1367, 0.0005921), IntersectionResultby([5363, 8739, 12242, 14529, 24924], 1067, 0.0007018), IntersectionResultby([1686, 6265, 9541, 14340, 43083, 43183, 44310, 44481, 46206], 1280, 0.0003812)], total_comparisons = 236662, total_time = 0.6875974000000001, total_result_length = 3627), (results = Any[IntersectionResultby([5239, 6162, 6806, 7411, 8951, 11279], 1383, 0.0027635), IntersectionResultby([5204, 5250, 6571, 8505, 21631, 30697, 36071], 2077, 0.0026191), IntersectionResultby([585, 1097, 2368, 8929, 11134, 11776, 14196, 14258, 17611, 24256, 26851, 27931, 37075, 37350, 37463, 49091], 2772, 0.0029741), IntersectionResultby([4961, 20059, 40091, 40106], 1104, 0.001035), IntersectionResultby([46886], 1259, 0.0010802), IntersectionResultby([314, 384, 675, 759, 2559, 3509, 4149, 4812, 5190, 5210  ‚Ä¶  45352, 45363, 45413, 45425, 45841, 46153, 47235, 48086, 49596, 49716], 5293, 0.0033613), IntersectionResultby([4273, 4702, 5081, 5122, 5145, 5311, 5330, 5366, 6409, 6532  ‚Ä¶  45007, 45284, 45330, 45734, 46040, 46048, 46127, 46751, 47542, 49570], 3863, 0.0018482), IntersectionResultby([297, 731, 743, 777, 936, 977, 1214, 1461, 1468, 1617  ‚Ä¶  44421, 45059, 45357, 45480, 46861, 47523, 49114, 49404, 49915, 49917], 2996, 0.0009311), IntersectionResultby([656, 745, 1256, 1783, 1948, 2080, 2156, 2202, 2624, 2749  ‚Ä¶  46040, 47368, 48106, 48710, 48928, 48967, 49076, 49214, 49229, 49593], 5215, 0.0061996), IntersectionResultby([4997, 5223, 5439, 5564, 5655, 5797, 6010, 6028, 6056, 6186  ‚Ä¶  6591, 6616, 6675, 6811, 7033, 10701, 12741, 17305, 30237, 34502], 1890, 0.0008448)  ‚Ä¶  IntersectionResultby([291, 738, 1196, 1234, 2041, 2050, 6757, 11740, 14447, 15428, 38763, 49954], 3146, 0.0046778), IntersectionResultby([15287, 42767], 1993, 0.0007), IntersectionResultby([2316, 12774, 12838, 18103, 23914, 27715, 40838, 44982], 2980, 0.0006408), IntersectionResultby([275, 1494, 1979, 2508, 19085, 21630, 28195, 36747], 2474, 0.0007673), IntersectionResultby([2703, 6305, 7111, 15456, 46674], 1421, 0.0009011), IntersectionResultby([36813, 45326], 1928, 0.0021574), IntersectionResultby([7418, 18463, 23704, 26896, 30677, 30977, 35574, 35602, 36832, 39841, 40630], 2216, 0.003412), IntersectionResultby([2909, 13712, 22475, 23606, 31618, 35409, 38102, 38625, 42221, 48249], 3324, 0.0013682), IntersectionResultby([15517, 33999], 2026, 0.0018652), IntersectionResultby([1196, 2728, 2991, 3126, 3518, 5661, 5911, 6009, 6205, 6470  ‚Ä¶  9513, 10155, 10441, 11787, 12583, 14361, 16645, 17346, 21983, 29133], 2412, 0.0007339)], total_comparisons = 478929, total_time = 0.30569720000000006, total_result_length = 4723), (results = Any[IntersectionResultby(Int64[], 1016, 0.0009319), IntersectionResultby([41697, 41975], 1162, 0.0015046), IntersectionResultby([1192, 2530, 5655, 5766, 5828, 6462, 6515, 6811, 7041, 7253  ‚Ä¶  44370, 44477, 44663, 45924, 46455, 46561, 46931, 47846, 47942, 48825], 1953, 0.0066795), IntersectionResultby([2309, 2334, 2826], 1190, 0.0007235), IntersectionResultby([4977, 5111, 9073, 9952], 988, 0.0006293), IntersectionResultby([2316, 5316, 5711, 6001, 7323, 8792, 9122, 9960, 10143, 10804, 11383, 11783, 16430, 17256, 17517, 20413, 20787, 32079, 46528], 1330, 0.0006352), IntersectionResultby([201, 443, 1903, 2568, 3571, 8904, 12928, 18489, 21396, 21644, 27378], 1900, 0.0010753), IntersectionResultby([9117, 14353, 41555], 1214, 0.0007497), IntersectionResultby([8289, 12366, 16834, 31510, 33936], 1626, 0.0005161), IntersectionResultby(Int64[], 922, 0.000567)  ‚Ä¶  IntersectionResultby([5743, 6042, 6720, 9994, 10879, 10898, 11978, 17668, 18037, 18504, 28427, 45377], 1176, 0.0006644), IntersectionResultby([42, 345, 616, 1808, 2090, 2795, 3133, 3912, 5039, 5240  ‚Ä¶  23904, 26098, 26870, 28427, 29213, 33474, 35853, 35996, 36747, 46097], 1431, 0.0005418), IntersectionResultby(Int64[], 1088, 0.0018264), IntersectionResultby([11327, 32778, 46318, 48218, 49861], 1763, 0.0011444), IntersectionResultby([2406, 4010, 23082, 25325, 37211, 41584, 42416, 44598, 44599], 1432, 0.0026898), IntersectionResultby([2466, 23191, 24711, 27172, 38942], 1207, 0.0004806), IntersectionResultby([15601, 22028, 27245, 30117, 30251, 47966, 49018], 1281, 0.0025573), IntersectionResultby([28029], 1123, 0.0009668), IntersectionResultby([1530, 2956, 22833, 39553], 1924, 0.0007055), IntersectionResultby(Int64[], 1331, 0.0003632)], total_comparisons = 270415, total_time = 0.24497200000000013, total_result_length = 1550), \"RESUMEN DE RESULTADOS (BAEZA-YATES CON B√öSQUEDA Binaria):\\n\\nCONJUNTO A (PARES):\\n- Total de pares procesados: 200\\n- Comparaciones totales: 236662\\n- Tiempo total (s): 0.687597\\n- Suma de longitudes de resultados: 3627\\n- Longitud promedio por resultado: 18.14\\n\\nCONJUNTO B (TRIPLETAS):\\n- Total de tripletas procesadas: 200\\n- Comparaciones totales: 478929\\n- Tiempo total (s): 0.305697\\n- Suma de longitudes de resultados: 4723\\n- Longitud promedio por resultado: 23.62\\n\\nCONJUNTO C (CU√ÅDRUPLES):\\n- Total de cu√°druples procesadas: 200\\n- Comparaciones totales: 270415\\n- Tiempo total (s): 0.244972\\n- Suma de longitudes de resultados: 1550\\n- Longitud promedio por resultado: 7.75\\n\")\n\n\n\ncompute_all_intersections_baeza_custom(A, B, C, exponential_search, \"Exponencial\")\n\nProcesando Conjunto A (pares) con Baeza-Yates y b√∫squeda Exponencial...\n\nProcesando Conjunto B (tripletas) con Baeza-Yates y b√∫squeda Exponencial...\n\nProcesando Conjunto C (cu√°druples) con Baeza-Yates y b√∫squeda Exponencial...\nRESUMEN DE RESULTADOS (BAEZA-YATES CON B√öSQUEDA Exponencial):\n\nCONJUNTO A (PARES):\n- Total de pares procesados: 200\n- Comparaciones totales: 229942\n- Tiempo total (s): 0.138168\n- Suma de longitudes de resultados: 3627\n- Longitud promedio por resultado: 18.14\n\nCONJUNTO B (TRIPLETAS):\n- Total de tripletas procesadas: 200\n- Comparaciones totales: 400028\n- Tiempo total (s): 0.115626\n- Suma de longitudes de resultados: 4723\n- Longitud promedio por resultado: 23.62\n\nCONJUNTO C (CU√ÅDRUPLES):\n- Total de cu√°druples procesadas: 200\n- Comparaciones totales: 235415\n- Tiempo total (s): 0.098732\n- Suma de longitudes de resultados: 1550\n- Longitud promedio por resultado: 7.75\n\n\n\n((results = Any[IntersectionResultby([6323, 12498], 1767, 0.0600775), IntersectionResultby([21109, 37491, 38824, 40060, 43252, 48615], 1102, 0.0001729), IntersectionResultby([10441], 873, 0.0001021), IntersectionResultby([227, 2802, 3122, 3220, 35566, 38126, 38679, 39587, 39971, 40488, 40976, 41053, 41367, 46954, 46955, 49582], 1132, 0.000174), IntersectionResultby([4850, 11205, 20287, 23256, 29729], 1070, 0.0001324), IntersectionResultby([4399, 5450, 10487, 25589], 1084, 0.0001268), IntersectionResultby([5194, 6030, 7380, 7932, 12040, 12583, 14811], 1020, 9.02e-5), IntersectionResultby([2729, 10222, 13543, 23966, 29304, 36381, 42776], 1099, 0.0001514), IntersectionResultby([337, 573, 676, 782, 1175, 1196, 1279, 3126, 3767, 4358  ‚Ä¶  42994, 43453, 43723, 44271, 44433, 44447, 44492, 44639, 45051, 47320], 1936, 0.0015794), IntersectionResultby([9008, 15039, 20863, 20870, 24643, 31997, 32817], 944, 0.0001368)  ‚Ä¶  IntersectionResultby([533, 2342, 4110, 6373, 6845, 11165, 14145, 14159, 14192, 14217  ‚Ä¶  36901, 37631, 39409, 42585, 42596, 45398, 45528, 47346, 47669, 47924], 1573, 0.0005212), IntersectionResultby([12189, 39789, 40618], 944, 8.78e-5), IntersectionResultby([1851, 2533, 2756, 2814, 8897, 17536], 833, 8.78e-5), IntersectionResultby([2673, 3189, 3275, 3565, 3729, 3897, 4486, 5944, 9708, 9731  ‚Ä¶  40963, 41278, 41469, 41530, 43418, 43965, 47263, 48515, 49005, 49175], 1747, 0.0016039), IntersectionResultby([5917, 5953, 6004, 6416, 7946, 9841, 12491, 22944, 46097], 1062, 9.8e-5), IntersectionResultby([613, 1244, 1871, 2271, 2893, 2908, 3296, 3559, 7308, 8196  ‚Ä¶  33616, 35432, 36646, 37509, 39507, 41946, 43243, 44808, 44973, 49738], 1601, 0.0009207), IntersectionResultby([15521, 21090, 22638], 1057, 0.0001424), IntersectionResultby([1097, 2487, 2503, 2770, 8216, 17669, 42376], 1181, 0.0002906), IntersectionResultby([5363, 8739, 12242, 14529, 24924], 1114, 0.0001524), IntersectionResultby([1686, 6265, 9541, 14340, 43083, 43183, 44310, 44481, 46206], 1228, 0.0001505)], total_comparisons = 229942, total_time = 0.13816779999999987, total_result_length = 3627), (results = Any[IntersectionResultby([5239, 6162, 6806, 7411, 8951, 11279], 1005, 0.0007604), IntersectionResultby([5204, 5250, 6571, 8505, 21631, 30697, 36071], 1577, 0.0008215), IntersectionResultby([585, 1097, 2368, 8929, 11134, 11776, 14196, 14258, 17611, 24256, 26851, 27931, 37075, 37350, 37463, 49091], 2494, 0.0009574), IntersectionResultby([4961, 20059, 40091, 40106], 954, 0.0003187), IntersectionResultby([46886], 929, 0.0001637), IntersectionResultby([314, 384, 675, 759, 2559, 3509, 4149, 4812, 5190, 5210  ‚Ä¶  45352, 45363, 45413, 45425, 45841, 46153, 47235, 48086, 49596, 49716], 4703, 0.0008844), IntersectionResultby([4273, 4702, 5081, 5122, 5145, 5311, 5330, 5366, 6409, 6532  ‚Ä¶  45007, 45284, 45330, 45734, 46040, 46048, 46127, 46751, 47542, 49570], 3625, 0.0010997), IntersectionResultby([297, 731, 743, 777, 936, 977, 1214, 1461, 1468, 1617  ‚Ä¶  44421, 45059, 45357, 45480, 46861, 47523, 49114, 49404, 49915, 49917], 2506, 0.0003634), IntersectionResultby([656, 745, 1256, 1783, 1948, 2080, 2156, 2202, 2624, 2749  ‚Ä¶  46040, 47368, 48106, 48710, 48928, 48967, 49076, 49214, 49229, 49593], 5694, 0.0023724), IntersectionResultby([4997, 5223, 5439, 5564, 5655, 5797, 6010, 6028, 6056, 6186  ‚Ä¶  6591, 6616, 6675, 6811, 7033, 10701, 12741, 17305, 30237, 34502], 1627, 0.0002117)  ‚Ä¶  IntersectionResultby([291, 738, 1196, 1234, 2041, 2050, 6757, 11740, 14447, 15428, 38763, 49954], 3277, 0.0008525), IntersectionResultby([15287, 42767], 1378, 0.000247), IntersectionResultby([2316, 12774, 12838, 18103, 23914, 27715, 40838, 44982], 2695, 0.0002478), IntersectionResultby([275, 1494, 1979, 2508, 19085, 21630, 28195, 36747], 2298, 0.0002161), IntersectionResultby([2703, 6305, 7111, 15456, 46674], 1320, 0.0002216), IntersectionResultby([36813, 45326], 1054, 0.0005284), IntersectionResultby([7418, 18463, 23704, 26896, 30677, 30977, 35574, 35602, 36832, 39841, 40630], 1724, 0.0014321), IntersectionResultby([2909, 13712, 22475, 23606, 31618, 35409, 38102, 38625, 42221, 48249], 3094, 0.0005703), IntersectionResultby([15517, 33999], 1440, 0.0007589), IntersectionResultby([1196, 2728, 2991, 3126, 3518, 5661, 5911, 6009, 6205, 6470  ‚Ä¶  9513, 10155, 10441, 11787, 12583, 14361, 16645, 17346, 21983, 29133], 1838, 0.0001548)], total_comparisons = 400028, total_time = 0.1156262, total_result_length = 4723), (results = Any[IntersectionResultby(Int64[], 831, 0.0001784), IntersectionResultby([41697, 41975], 949, 0.0005421), IntersectionResultby([1192, 2530, 5655, 5766, 5828, 6462, 6515, 6811, 7041, 7253  ‚Ä¶  44370, 44477, 44663, 45924, 46455, 46561, 46931, 47846, 47942, 48825], 2134, 0.0015116), IntersectionResultby([2309, 2334, 2826], 950, 0.0002284), IntersectionResultby([4977, 5111, 9073, 9952], 806, 0.0001386), IntersectionResultby([2316, 5316, 5711, 6001, 7323, 8792, 9122, 9960, 10143, 10804, 11383, 11783, 16430, 17256, 17517, 20413, 20787, 32079, 46528], 1247, 0.0001858), IntersectionResultby([201, 443, 1903, 2568, 3571, 8904, 12928, 18489, 21396, 21644, 27378], 1843, 0.0003854), IntersectionResultby([9117, 14353, 41555], 919, 0.000192), IntersectionResultby([8289, 12366, 16834, 31510, 33936], 1573, 0.0002312), IntersectionResultby(Int64[], 725, 0.0006072)  ‚Ä¶  IntersectionResultby([5743, 6042, 6720, 9994, 10879, 10898, 11978, 17668, 18037, 18504, 28427, 45377], 1091, 0.0003507), IntersectionResultby([42, 345, 616, 1808, 2090, 2795, 3133, 3912, 5039, 5240  ‚Ä¶  23904, 26098, 26870, 28427, 29213, 33474, 35853, 35996, 36747, 46097], 1330, 0.0001651), IntersectionResultby(Int64[], 941, 0.0006089), IntersectionResultby([11327, 32778, 46318, 48218, 49861], 1647, 0.0003554), IntersectionResultby([2406, 4010, 23082, 25325, 37211, 41584, 42416, 44598, 44599], 1127, 0.0037482), IntersectionResultby([2466, 23191, 24711, 27172, 38942], 1007, 0.000203), IntersectionResultby([15601, 22028, 27245, 30117, 30251, 47966, 49018], 1205, 0.000968), IntersectionResultby([28029], 909, 0.0001926), IntersectionResultby([1530, 2956, 22833, 39553], 1906, 0.0002667), IntersectionResultby(Int64[], 948, 0.0001939)], total_comparisons = 235415, total_time = 0.09873159999999999, total_result_length = 1550), \"RESUMEN DE RESULTADOS (BAEZA-YATES CON B√öSQUEDA Exponencial):\\n\\nCONJUNTO A (PARES):\\n- Total de pares procesados: 200\\n- Comparaciones totales: 229942\\n- Tiempo total (s): 0.138168\\n- Suma de longitudes de resultados: 3627\\n- Longitud promedio por resultado: 18.14\\n\\nCONJUNTO B (TRIPLETAS):\\n- Total de tripletas procesadas: 200\\n- Comparaciones totales: 400028\\n- Tiempo total (s): 0.115626\\n- Suma de longitudes de resultados: 4723\\n- Longitud promedio por resultado: 23.62\\n\\nCONJUNTO C (CU√ÅDRUPLES):\\n- Total de cu√°druples procesadas: 200\\n- Comparaciones totales: 235415\\n- Tiempo total (s): 0.098732\\n- Suma de longitudes de resultados: 1550\\n- Longitud promedio por resultado: 7.75\\n\")\n\n\n\ncompute_all_intersections_baeza_custom(A, B, C, doubling_search, \"B2\")\n\nProcesando Conjunto A (pares) con Baeza-Yates y b√∫squeda B2...\n\nProcesando Conjunto B (tripletas) con Baeza-Yates y b√∫squeda B2...\n\nProcesando Conjunto C (cu√°druples) con Baeza-Yates y b√∫squeda B2...\nRESUMEN DE RESULTADOS (BAEZA-YATES CON B√öSQUEDA B2):\n\nCONJUNTO A (PARES):\n- Total de pares procesados: 200\n- Comparaciones totales: 229942\n- Tiempo total (s): 0.126267\n- Suma de longitudes de resultados: 3627\n- Longitud promedio por resultado: 18.14\n\nCONJUNTO B (TRIPLETAS):\n- Total de tripletas procesadas: 200\n- Comparaciones totales: 400028\n- Tiempo total (s): 0.106735\n- Suma de longitudes de resultados: 4723\n- Longitud promedio por resultado: 23.62\n\nCONJUNTO C (CU√ÅDRUPLES):\n- Total de cu√°druples procesadas: 200\n- Comparaciones totales: 235415\n- Tiempo total (s): 0.086077\n- Suma de longitudes de resultados: 1550\n- Longitud promedio por resultado: 7.75\n\n\n\n((results = Any[IntersectionResultby([6323, 12498], 1767, 0.0662942), IntersectionResultby([21109, 37491, 38824, 40060, 43252, 48615], 1102, 0.0004762), IntersectionResultby([10441], 873, 0.0003053), IntersectionResultby([227, 2802, 3122, 3220, 35566, 38126, 38679, 39587, 39971, 40488, 40976, 41053, 41367, 46954, 46955, 49582], 1132, 0.00049), IntersectionResultby([4850, 11205, 20287, 23256, 29729], 1070, 0.0001446), IntersectionResultby([4399, 5450, 10487, 25589], 1084, 0.0001202), IntersectionResultby([5194, 6030, 7380, 7932, 12040, 12583, 14811], 1020, 8.81e-5), IntersectionResultby([2729, 10222, 13543, 23966, 29304, 36381, 42776], 1099, 0.0001489), IntersectionResultby([337, 573, 676, 782, 1175, 1196, 1279, 3126, 3767, 4358  ‚Ä¶  42994, 43453, 43723, 44271, 44433, 44447, 44492, 44639, 45051, 47320], 1936, 0.0015054), IntersectionResultby([9008, 15039, 20863, 20870, 24643, 31997, 32817], 944, 0.0001253)  ‚Ä¶  IntersectionResultby([533, 2342, 4110, 6373, 6845, 11165, 14145, 14159, 14192, 14217  ‚Ä¶  36901, 37631, 39409, 42585, 42596, 45398, 45528, 47346, 47669, 47924], 1573, 0.0004952), IntersectionResultby([12189, 39789, 40618], 944, 8.38e-5), IntersectionResultby([1851, 2533, 2756, 2814, 8897, 17536], 833, 8.35e-5), IntersectionResultby([2673, 3189, 3275, 3565, 3729, 3897, 4486, 5944, 9708, 9731  ‚Ä¶  40963, 41278, 41469, 41530, 43418, 43965, 47263, 48515, 49005, 49175], 1747, 0.001359), IntersectionResultby([5917, 5953, 6004, 6416, 7946, 9841, 12491, 22944, 46097], 1062, 8.36e-5), IntersectionResultby([613, 1244, 1871, 2271, 2893, 2908, 3296, 3559, 7308, 8196  ‚Ä¶  33616, 35432, 36646, 37509, 39507, 41946, 43243, 44808, 44973, 49738], 1601, 0.0007095), IntersectionResultby([15521, 21090, 22638], 1057, 0.0001246), IntersectionResultby([1097, 2487, 2503, 2770, 8216, 17669, 42376], 1181, 0.0001501), IntersectionResultby([5363, 8739, 12242, 14529, 24924], 1114, 0.0001359), IntersectionResultby([1686, 6265, 9541, 14340, 43083, 43183, 44310, 44481, 46206], 1228, 0.0001369)], total_comparisons = 229942, total_time = 0.12626689999999993, total_result_length = 3627), (results = Any[IntersectionResultby([5239, 6162, 6806, 7411, 8951, 11279], 1005, 0.0005328), IntersectionResultby([5204, 5250, 6571, 8505, 21631, 30697, 36071], 1577, 0.0007714), IntersectionResultby([585, 1097, 2368, 8929, 11134, 11776, 14196, 14258, 17611, 24256, 26851, 27931, 37075, 37350, 37463, 49091], 2494, 0.0008658), IntersectionResultby([4961, 20059, 40091, 40106], 954, 0.0002881), IntersectionResultby([46886], 929, 0.0001453), IntersectionResultby([314, 384, 675, 759, 2559, 3509, 4149, 4812, 5190, 5210  ‚Ä¶  45352, 45363, 45413, 45425, 45841, 46153, 47235, 48086, 49596, 49716], 4703, 0.0055194), IntersectionResultby([4273, 4702, 5081, 5122, 5145, 5311, 5330, 5366, 6409, 6532  ‚Ä¶  45007, 45284, 45330, 45734, 46040, 46048, 46127, 46751, 47542, 49570], 3625, 0.0006207), IntersectionResultby([297, 731, 743, 777, 936, 977, 1214, 1461, 1468, 1617  ‚Ä¶  44421, 45059, 45357, 45480, 46861, 47523, 49114, 49404, 49915, 49917], 2506, 0.0001641), IntersectionResultby([656, 745, 1256, 1783, 1948, 2080, 2156, 2202, 2624, 2749  ‚Ä¶  46040, 47368, 48106, 48710, 48928, 48967, 49076, 49214, 49229, 49593], 5694, 0.0019199), IntersectionResultby([4997, 5223, 5439, 5564, 5655, 5797, 6010, 6028, 6056, 6186  ‚Ä¶  6591, 6616, 6675, 6811, 7033, 10701, 12741, 17305, 30237, 34502], 1627, 0.0001821)  ‚Ä¶  IntersectionResultby([291, 738, 1196, 1234, 2041, 2050, 6757, 11740, 14447, 15428, 38763, 49954], 3277, 0.0007993), IntersectionResultby([15287, 42767], 1378, 0.0002207), IntersectionResultby([2316, 12774, 12838, 18103, 23914, 27715, 40838, 44982], 2695, 0.0002005), IntersectionResultby([275, 1494, 1979, 2508, 19085, 21630, 28195, 36747], 2298, 0.0002118), IntersectionResultby([2703, 6305, 7111, 15456, 46674], 1320, 0.0002049), IntersectionResultby([36813, 45326], 1054, 0.0004898), IntersectionResultby([7418, 18463, 23704, 26896, 30677, 30977, 35574, 35602, 36832, 39841, 40630], 1724, 0.0013194), IntersectionResultby([2909, 13712, 22475, 23606, 31618, 35409, 38102, 38625, 42221, 48249], 3094, 0.0005277), IntersectionResultby([15517, 33999], 1440, 0.0007373), IntersectionResultby([1196, 2728, 2991, 3126, 3518, 5661, 5911, 6009, 6205, 6470  ‚Ä¶  9513, 10155, 10441, 11787, 12583, 14361, 16645, 17346, 21983, 29133], 1838, 0.0001482)], total_comparisons = 400028, total_time = 0.10673520000000002, total_result_length = 4723), (results = Any[IntersectionResultby(Int64[], 831, 0.0001719), IntersectionResultby([41697, 41975], 949, 0.0005153), IntersectionResultby([1192, 2530, 5655, 5766, 5828, 6462, 6515, 6811, 7041, 7253  ‚Ä¶  44370, 44477, 44663, 45924, 46455, 46561, 46931, 47846, 47942, 48825], 2134, 0.0014266), IntersectionResultby([2309, 2334, 2826], 950, 0.0001723), IntersectionResultby([4977, 5111, 9073, 9952], 806, 0.0001163), IntersectionResultby([2316, 5316, 5711, 6001, 7323, 8792, 9122, 9960, 10143, 10804, 11383, 11783, 16430, 17256, 17517, 20413, 20787, 32079, 46528], 1247, 0.0001744), IntersectionResultby([201, 443, 1903, 2568, 3571, 8904, 12928, 18489, 21396, 21644, 27378], 1843, 0.0003656), IntersectionResultby([9117, 14353, 41555], 919, 0.0001896), IntersectionResultby([8289, 12366, 16834, 31510, 33936], 1573, 0.0002114), IntersectionResultby(Int64[], 725, 0.0001419)  ‚Ä¶  IntersectionResultby([5743, 6042, 6720, 9994, 10879, 10898, 11978, 17668, 18037, 18504, 28427, 45377], 1091, 0.0002045), IntersectionResultby([42, 345, 616, 1808, 2090, 2795, 3133, 3912, 5039, 5240  ‚Ä¶  23904, 26098, 26870, 28427, 29213, 33474, 35853, 35996, 36747, 46097], 1330, 0.0001596), IntersectionResultby(Int64[], 941, 0.000606), IntersectionResultby([11327, 32778, 46318, 48218, 49861], 1647, 0.0003564), IntersectionResultby([2406, 4010, 23082, 25325, 37211, 41584, 42416, 44598, 44599], 1127, 0.0007915), IntersectionResultby([2466, 23191, 24711, 27172, 38942], 1007, 0.000184), IntersectionResultby([15601, 22028, 27245, 30117, 30251, 47966, 49018], 1205, 0.0009023), IntersectionResultby([28029], 909, 0.0001732), IntersectionResultby([1530, 2956, 22833, 39553], 1906, 0.0003101), IntersectionResultby(Int64[], 948, 0.0002936)], total_comparisons = 235415, total_time = 0.08607699999999996, total_result_length = 1550), \"RESUMEN DE RESULTADOS (BAEZA-YATES CON B√öSQUEDA B2):\\n\\nCONJUNTO A (PARES):\\n- Total de pares procesados: 200\\n- Comparaciones totales: 229942\\n- Tiempo total (s): 0.126267\\n- Suma de longitudes de resultados: 3627\\n- Longitud promedio por resultado: 18.14\\n\\nCONJUNTO B (TRIPLETAS):\\n- Total de tripletas procesadas: 200\\n- Comparaciones totales: 400028\\n- Tiempo total (s): 0.106735\\n- Suma de longitudes de resultados: 4723\\n- Longitud promedio por resultado: 23.62\\n\\nCONJUNTO C (CU√ÅDRUPLES):\\n- Total de cu√°druples procesadas: 200\\n- Comparaciones totales: 235415\\n- Tiempo total (s): 0.086077\\n- Suma de longitudes de resultados: 1550\\n- Longitud promedio por resultado: 7.75\\n\")"
  },
  {
    "objectID": "VillegasJoseAlbertoU5-T1.html#barbay-kenyon-bk",
    "href": "VillegasJoseAlbertoU5-T1.html#barbay-kenyon-bk",
    "title": "Unidad 5. Algoritmos de intersecci√≥n y uni√≥n de conjuntos en el modelo de comparaci√≥n",
    "section": "Barbay & Kenyon \\((BK)\\)",
    "text": "Barbay & Kenyon \\((BK)\\)\nEl algoritmo de Barbay y Kenyon es un algoritmo adaptativo para la intersecci√≥n de listas ordenadas, propuesto por J√©r√©my Barbay y Claire Kenyon en su art√≠culo ‚ÄúAdaptive intersection and t-threshold problems‚Äù, presentado en el SODA 2002 (Symposium on Discrete Algorithms).\nBarbay y Kenyon (2002) proponen algoritmos adaptativos que ajustan su complejidad seg√∫n la ‚Äúdificultad‚Äù de la instancia, definida en t√©rminos de la estructura no determinista del problema. El algoritmo presentado se basa en una b√∫squeda por duplicaci√≥n y binaria para calcular la intersecci√≥n de \\(k\\) conjuntos ordenados de manera √≥ptima.\nComplejidad:\n\\(O(kŒ¥log(n/Œ¥))\\), donde \\(Œ¥\\) es la dificultad de la instancia.\n\nPlan de implementaci√≥n\n\nSe definir√° una funci√≥n base para realizar la intersecci√≥n de dos conjuntos por \\(BK\\)\nSe definir√°n funciones de soporte que nos permitir√°n procesar los datos en funci√≥n del tipo de conjunto ( Para pares, tripletas y cuadruples de listas)\nSe definir√° una funci√≥n para computar todas las intersecciones. Esta, a su vez, generar√° un reporte con m√©tricas para medir el desempe√±o del algoritmo, como; tiempo de ejecuci√≥n, n√∫mero de comparaciones y las longitudes de las intersecciones para cada conjunto de datos.\n\n\n# Estructura para almacenar resultados\nstruct IntersectionResultBK\n    result::Vector{Int}\n    comparisons::Int\n    time_taken::Float64\nend\n\n# Funci√≥n base: algoritmo de Barbay-Kenyon \nfunction intersect_bk!(result::Vector{Int}, lists::Vector{Vector{Int}})\n    comparisons = 0\n    k = length(lists)\n    \n    # Ordenar listas por longitud ascendente\n    #sorted_lists = sort(lists, by=length)\n    P = ones(Int, k)  # Posiciones iniciales\n    \n    # Funci√≥n de b√∫squeda binaria \n    function binary_findpos(lst::Vector{Int}, val::Int, start::Int)\n        low, high = start, length(lst)\n        while low &lt;= high\n            comparisons += 1\n            mid = div(low + high, 2)\n            if lst[mid] == val\n                return mid\n            elseif lst[mid] &lt; val\n                low = mid + 1\n            else\n                high = mid - 1\n            end\n        end\n        return low &gt; length(lst) ? length(lst)+1 : low\n    end\n\n    # Implementaci√≥n del algoritmo BK \n    _max = lists[1][1]\n    c = 0\n    i = 1\n    \n    @inbounds while true\n        for i in eachindex(P)\n            P[i] = binary_findpos(lists[i], _max, P[i])\n            P[i] &gt; length(lists[i]) && return comparisons\n            \n            pval = lists[i][P[i]]\n            if pval == _max\n                c += 1\n                if c == k\n                    push!(result, _max)\n                    comparisons += 1  # Contamos la comparaci√≥n final\n                    c = 0\n                    P[i] += 1\n                    P[i] &gt; length(lists[i]) && return comparisons\n                    _max = lists[i][P[i]]\n                end\n            else\n                c = 0\n                _max = pval\n            end\n        end\n    end\n    \n    return comparisons\nend\n\n# Funci√≥n generalizada para pares, tripletas, cu√°druples \nfunction intersect_bk_groups(groups)\n    results = []\n    total_comparisons = 0\n    total_time = 0.0\n    total_result_length = 0\n\n    for group in groups\n        result = Int[]\n        time_taken = @elapsed begin\n            comparisons = intersect_bk!(result, [Vector{Int}(x) for x in group])\n        end\n        push!(results, IntersectionResultBK(result, comparisons, time_taken))\n        total_comparisons += comparisons\n        total_time += time_taken\n        total_result_length += length(result)\n    end\n\n    return (\n        results=results,\n        total_comparisons=total_comparisons,\n        total_time=total_time,\n        total_result_length=total_result_length\n    )\nend\n\n# Funci√≥n general para procesar todos los conjuntos y generar reporte\nfunction compute_all_intersections_bk(pairs_A, triplets_B, quadruples_C)\n    println(\"Procesando Conjunto A (pares) con Barbay-Kenyon...\")\n    result_A = intersect_bk_groups(pairs_A)\n\n    println(\"\\nProcesando Conjunto B (tripletas) con Barbay-Kenyon...\")\n    result_B = intersect_bk_groups(triplets_B)\n\n    println(\"\\nProcesando Conjunto C (cu√°druples) con Barbay-Kenyon...\")\n    result_C = intersect_bk_groups(quadruples_C)\n\n    report = \"\"\"\n    RESUMEN DE RESULTADOS (BARBAY-KENYON):\n    \n    CONJUNTO A (PARES):\n    - Total de pares procesados: $(length(pairs_A))\n    - Comparaciones totales: $(result_A.total_comparisons)\n    - Tiempo total (s): $(round(result_A.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_A.total_result_length)\n    - Longitud promedio por resultado: $(round(result_A.total_result_length / max(length(pairs_A),1), digits=2))\n\n    CONJUNTO B (TRIPLETAS):\n    - Total de tripletas procesadas: $(length(triplets_B))\n    - Comparaciones totales: $(result_B.total_comparisons)\n    - Tiempo total (s): $(round(result_B.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_B.total_result_length)\n    - Longitud promedio por resultado: $(round(result_B.total_result_length / max(length(triplets_B),1), digits=2))\n\n    CONJUNTO C (CU√ÅDRUPLES):\n    - Total de cu√°druples procesadas: $(length(quadruples_C))\n    - Comparaciones totales: $(result_C.total_comparisons)\n    - Tiempo total (s): $(round(result_C.total_time, digits=6))\n    - Suma de longitudes de resultados: $(result_C.total_result_length)\n    - Longitud promedio por resultado: $(round(result_C.total_result_length / max(length(quadruples_C),1), digits=2))\n    \"\"\"\n\n    println(report)\n\n    return (result_A, result_B, result_C, report)\nend\n\ncompute_all_intersections_bk (generic function with 1 method)\n\n\n\ncompute_all_intersections_bk(A,B, C)\n\nProcesando Conjunto A (pares) con Barbay-Kenyon...\n\nProcesando Conjunto B (tripletas) con Barbay-Kenyon...\n\nProcesando Conjunto C (cu√°druples) con Barbay-Kenyon...\nRESUMEN DE RESULTADOS (BARBAY-KENYON):\n\nCONJUNTO A (PARES):\n- Total de pares procesados: 200\n- Comparaciones totales: 316355\n- Tiempo total (s): 0.472339\n- Suma de longitudes de resultados: 3770\n- Longitud promedio por resultado: 18.85\n\nCONJUNTO B (TRIPLETAS):\n- Total de tripletas procesadas: 200\n- Comparaciones totales: 857660\n- Tiempo total (s): 0.2474\n- Suma de longitudes de resultados: 4763\n- Longitud promedio por resultado: 23.82\n\nCONJUNTO C (CU√ÅDRUPLES):\n- Total de cu√°druples procesadas: 200\n- Comparaciones totales: 460476\n- Tiempo total (s): 0.18608\n- Suma de longitudes de resultados: 1637\n- Longitud promedio por resultado: 8.18\n\n\n\n((results = Any[IntersectionResultBK([6323, 12498], 2034, 0.3122745), IntersectionResultBK([21109, 37491, 37491, 38824, 40060, 40060, 43252, 48615], 1520, 0.0003135), IntersectionResultBK([10441], 1282, 0.0002289), IntersectionResultBK([227, 2802, 3122, 3220, 35566, 38126, 38679, 39587, 39971, 40488, 40976, 41053, 41367, 46954, 46955, 49582], 1582, 0.0004398), IntersectionResultBK([4850, 11205, 20287, 23256, 29729], 1603, 0.0002843), IntersectionResultBK([4399, 5450, 10487, 25589], 1634, 0.0002956), IntersectionResultBK([5194, 6030, 7380, 7932, 12040, 12583, 14811], 1409, 0.0002459), IntersectionResultBK([2729, 10222, 10222, 13543, 23966, 29304, 36381, 42776], 1394, 0.0003665), IntersectionResultBK([337, 573, 676, 782, 1175, 1175, 1196, 1279, 3126, 3767  ‚Ä¶  42994, 43453, 43723, 44271, 44433, 44447, 44492, 44639, 45051, 47320], 2382, 0.0040738), IntersectionResultBK([9008, 15039, 20863, 20870, 24643, 31997, 32817], 1459, 0.0004104)  ‚Ä¶  IntersectionResultBK([533, 2342, 4110, 6373, 6845, 11165, 14145, 14159, 14192, 14217  ‚Ä¶  36901, 37631, 39409, 42585, 42596, 45398, 45528, 47346, 47669, 47924], 1885, 0.0011279), IntersectionResultBK([12189, 39789, 40618], 1365, 0.0003966), IntersectionResultBK([1851, 2533, 2756, 2814, 8897, 17536], 1226, 0.000295), IntersectionResultBK([2673, 3189, 3275, 3565, 3729, 3897, 4486, 4486, 5944, 9708  ‚Ä¶  40963, 41278, 41469, 41530, 43418, 43965, 47263, 48515, 49005, 49175], 2147, 0.0032676), IntersectionResultBK([5917, 5953, 6004, 6416, 6416, 7946, 7946, 9841, 12491, 22944, 46097], 1602, 0.0002116), IntersectionResultBK([613, 1244, 1871, 2271, 2893, 2908, 3296, 3559, 7308, 8196  ‚Ä¶  33616, 35432, 36646, 37509, 39507, 41946, 43243, 44808, 44973, 49738], 1842, 0.00213), IntersectionResultBK([15521, 21090, 22638, 22638], 1617, 0.0069215), IntersectionResultBK([1097, 2487, 2503, 2770, 8216, 17669, 42376], 1796, 0.0002813), IntersectionResultBK([5363, 8739, 12242, 14529, 24924], 1476, 0.0003568), IntersectionResultBK([1686, 6265, 9541, 14340, 43083, 43183, 44310, 44481, 46206], 1695, 0.0002532)], total_comparisons = 316355, total_time = 0.4723394000000001, total_result_length = 3770), (results = Any[IntersectionResultBK([5239, 6162, 6806, 7411, 8951, 11279], 2586, 0.0014856), IntersectionResultBK([5204, 5250, 6571, 8505, 21631, 30697, 36071], 4903, 0.0017187), IntersectionResultBK([585, 1097, 2368, 8929, 11134, 11776, 14196, 14258, 17611, 24256, 26851, 27931, 37075, 37350, 37463, 49091], 6791, 0.0016961), IntersectionResultBK([4961, 20059, 40091, 40106], 2706, 0.0006107), IntersectionResultBK([46886], 2273, 0.0003048), IntersectionResultBK([314, 384, 675, 759, 2559, 3509, 4149, 4812, 5190, 5210  ‚Ä¶  45352, 45363, 45413, 45425, 45841, 46153, 47235, 48086, 49596, 49716], 6914, 0.0018055), IntersectionResultBK([4273, 4702, 5081, 5122, 5145, 5311, 5330, 5366, 6409, 6532  ‚Ä¶  45007, 45284, 45330, 45734, 46040, 46048, 46127, 46751, 47542, 49570], 5008, 0.0015027), IntersectionResultBK([297, 731, 743, 777, 936, 977, 1214, 1461, 1468, 1617  ‚Ä¶  44421, 45059, 45357, 45480, 46861, 47523, 49114, 49404, 49915, 49917], 4027, 0.0003866), IntersectionResultBK([656, 745, 1256, 1783, 1948, 2080, 2156, 2202, 2624, 2749  ‚Ä¶  46040, 47368, 48106, 48710, 48928, 48967, 49076, 49214, 49229, 49593], 6619, 0.0040181), IntersectionResultBK([4997, 5223, 5439, 5564, 5655, 5797, 6010, 6028, 6056, 6186  ‚Ä¶  6591, 6616, 6675, 6811, 7033, 10701, 12741, 17305, 30237, 34502], 3989, 0.000464)  ‚Ä¶  IntersectionResultBK([291, 738, 1196, 1234, 2041, 2050, 6757, 11740, 14447, 15428, 38763, 49954], 4016, 0.0018549), IntersectionResultBK([15287, 42767], 3790, 0.0006318), IntersectionResultBK([2316, 12774, 12838, 18103, 23914, 27715, 40838, 44982], 3380, 0.0004496), IntersectionResultBK([275, 1494, 1979, 2508, 19085, 21630, 28195, 36747], 2978, 0.0004588), IntersectionResultBK([2703, 6305, 7111, 15456, 46674], 3127, 0.0005092), IntersectionResultBK([36813, 45326], 3336, 0.0010826), IntersectionResultBK([7418, 18463, 23704, 26896, 30677, 30977, 35574, 35602, 36832, 39841, 40630], 5140, 0.0043514), IntersectionResultBK([2909, 13712, 22475, 23606, 31618, 35409, 38102, 38625, 42221, 48249], 4248, 0.0013938), IntersectionResultBK([15517, 33999], 5413, 0.0014987), IntersectionResultBK([1196, 2728, 2991, 3126, 3518, 5661, 5911, 6009, 6205, 6470  ‚Ä¶  9513, 10155, 10441, 11787, 12583, 14361, 16645, 17346, 21983, 29133], 5094, 0.0004506)], total_comparisons = 857660, total_time = 0.24740030000000002, total_result_length = 4763), (results = Any[IntersectionResultBK(Int64[], 2069, 0.0004117), IntersectionResultBK([41697, 41975], 2466, 0.0011205), IntersectionResultBK([1192, 2530, 5655, 5766, 5828, 5828, 6462, 6462, 6515, 6515  ‚Ä¶  44370, 44477, 44663, 45924, 46455, 46561, 46931, 47846, 47942, 48825], 2959, 0.0029431), IntersectionResultBK([2309, 2334, 2826], 2355, 0.0004417), IntersectionResultBK([4977, 5111, 9073, 9952], 1781, 0.0003001), IntersectionResultBK([2316, 5316, 5711, 6001, 7323, 8792, 9122, 9122, 9960, 10143, 10804, 11383, 11783, 16430, 17256, 17517, 20413, 20787, 32079, 46528], 2209, 0.0003604), IntersectionResultBK([201, 443, 1903, 2568, 3571, 8904, 12928, 18489, 21396, 21644, 27378], 2466, 0.0008686), IntersectionResultBK([9117, 14353, 41555], 1977, 0.000395), IntersectionResultBK([8289, 12366, 16834, 31510, 33936], 2183, 0.0005303), IntersectionResultBK(Int64[], 1780, 0.0003354)  ‚Ä¶  IntersectionResultBK([5743, 5743, 6042, 6720, 9994, 10879, 10898, 10898, 11978, 17668, 18037, 18504, 28427, 45377], 2371, 0.0004603), IntersectionResultBK([42, 345, 616, 1808, 2090, 2795, 3133, 3912, 5039, 5240  ‚Ä¶  23904, 26098, 26870, 28427, 29213, 33474, 35853, 35996, 36747, 46097], 2330, 0.0003595), IntersectionResultBK(Int64[], 2427, 0.0011854), IntersectionResultBK([11327, 32778, 46318, 48218, 49861], 2401, 0.0007962), IntersectionResultBK([2406, 4010, 23082, 25325, 37211, 41584, 42416, 44598, 44599], 2889, 0.0015695), IntersectionResultBK([2466, 23191, 24711, 27172, 38942], 2138, 0.0003949), IntersectionResultBK([15601, 22028, 27245, 30117, 30251, 47966, 49018], 2623, 0.0019411), IntersectionResultBK([28029], 2316, 0.0004598), IntersectionResultBK([1530, 2956, 2956, 22833, 39553], 2638, 0.0006198), IntersectionResultBK(Int64[], 2296, 0.0003896)], total_comparisons = 460476, total_time = 0.18608049999999987, total_result_length = 1637), \"RESUMEN DE RESULTADOS (BARBAY-KENYON):\\n\\nCONJUNTO A (PARES):\\n- Total de pares procesados: 200\\n- Comparaciones totales: 316355\\n- Tiempo total (s): 0.472339\\n- Suma de longitudes de resultados: 3770\\n- Longitud promedio por resultado: 18.85\\n\\nCONJUNTO B (TRIPLETAS):\\n- Total de tripletas procesadas: 200\\n- Comparaciones totales: 857660\\n- Tiempo total (s): 0.2474\\n- Suma de longitudes de resultados: 4763\\n- Longitud promedio por resultado: 23.82\\n\\nCONJUNTO C (CU√ÅDRUPLES):\\n- Total de cu√°druples procesadas: 200\\n- Comparaciones totales: 460476\\n- Tiempo total (s): 0.18608\\n- Suma de longitudes de resultados: 1637\\n- Longitud promedio por resultado: 8.18\\n\")"
  },
  {
    "objectID": "VillegasJoseAlbertoU5-T1.html#dicusi√≥n-de-resultados",
    "href": "VillegasJoseAlbertoU5-T1.html#dicusi√≥n-de-resultados",
    "title": "Unidad 5. Algoritmos de intersecci√≥n y uni√≥n de conjuntos en el modelo de comparaci√≥n",
    "section": "Dicusi√≥n de Resultados",
    "text": "Dicusi√≥n de Resultados\n\nTabla 1. Comparaci√≥n de tiempo de ejecuci√≥n (segundos) de cada algoritmo para cada conjunto.\n\\[\n\\begin{array}{|l|c|c|c|}\n\\hline\n\\textbf{} & \\textbf{Conjunto (A)}\\ \\text{pares} & \\textbf{Conjunto (B)}\\ \\text{tripletas} & \\textbf{Conjunto (C)}\\ \\text{cu√°druples} \\\\\n\\hline\n\\text{ME} & 0.072497 & 0.131184 & 0.221043 \\\\\n\\text{BY Bisecci√≥n} & 0.687597 & 0.305697 & 0.244972 \\\\\n\\text{BY } B_{1} & 0.138168 & 0.115626 & 0.098732 \\\\\n\\text{BY } B_{2} & 0.126267 & 0.106735 & 0.086077 \\\\\n\\text{BK} & 0.472339 & 0.2474   & 0.18608 \\\\\n\\hline\n\\end{array}\n\\]\nDe la Tabla 1, se puede observar la siguiente:\n\n1. Comportamiento de ME (Melding)\n\nEs el algoritmo m√°s r√°pido para pares, lo que podr√≠a sugerir que la diferencia en el tama√±o de las listas del conjunto A no es tan grande.\nSu rendimiento empeora significativamente con tripletas y cu√°druples. Esto sugiere que no escala bien con la aridad de la intersecci√≥n, esto seguramente se debe a que este algoritmo tiene que inspeccionar todos los elementos de las listas de los conjuntos.\n\n\n\n2. BY (Baeza-Yates) con b√∫squeda binaria cl√°sica (bisecci√≥n)\n\nEs el m√°s lento para pares (0.6876s).\nLa tendencia de su rendimiento es mejorar al aumentar la aridad, lo cual podr√≠a deberse a que las intersecciones son m√°s dispersas, haciendo m√°s eficientes las b√∫squedas binarias.\nAun as√≠, es el algoritmo menos eficiente en general, en t√©rminos de tiempo de ejecuci√≥n.\n\n\n\n3. BY (Baeza-Yates) con \\(B_1\\) y \\(B_2\\)\n\nSuperan claramente a la bisecci√≥n.\n\\(B_2\\) es m√°s r√°pido que \\(B_1\\), como se espera te√≥ricamente.\nSon los m√°s eficientes para tripletas y cu√°druples.\nEscalan muy bien con la aridad.\n\n\n\n4. BK (Barbay-Kenyon)\n\nTiene un rendimiento intermedio: mejor que \\(BY\\) Bisecci√≥n, pero peor que \\(BY\\) \\(B_2\\).\nTambi√©n escala bien, con tiempos decrecientes al aumentar la aridad.\n\n\n\n\n\nTabla 2. N√∫mero de comparaciones realizadas por cada algoritmo para cada conjunto.\n\\[\n\\begin{array}{|l|c|c|c|}\n\\hline\n\\textbf{} & \\textbf{Conjunto (A)}\\ \\text{pares} & \\textbf{Conjunto (B)}\\ \\text{tripletas} & \\textbf{Conjunto (C)}\\ \\text{cu√°druples} \\\\\n\\hline\n\\text{ME} & 3\\,238\\,899 & 5\\,276\\,587 & 4\\,261\\,034 \\\\\n\\text{BY Bisecci√≥n} & 236\\,662 & 478\\,929 & 270\\,415 \\\\\n\\text{BY } B_{1} & 229\\,942 & 400\\,028 & 235\\,415 \\\\\n\\text{BY } B_{2} & 229\\,942 & 400\\,028 & 235\\,415 \\\\\n\\text{BK} & 316\\,355 & 857\\,660 & 460\\,476 \\\\\n\\hline\n\\end{array}\n\\]\nDe la Tabla 2, se puede observar la siguiente:\n\n1. ME (Melding)\n\nRealiza la mayor cantidad de comparaciones por un amplio margen. Este compartamiento es esperado, pues de antemano se sabe que el algoritmo inspecciona todos los elementos de los conjuntos.\nEspecialmente ineficiente en tripletas, con m√°s de 5 millones de comparaciones. Esto explica su bajo rendimiento en tiempo: su carga computacional es muy alta.\n\n\n\n2. BY (Baeza-Yates) con b√∫squeda binaria cl√°sica (bisecci√≥n)\n\nRealiza muchas menos comparaciones que \\(ME\\).\nSin embargo, es superado cuando se utilizan como funci√≥n de b√∫squeda: \\(B_1\\) y \\(B_2\\) .\n\n\n\n3. BY (Baeza-Yates) con \\(B_1\\) y \\(B_2\\)\n\nAmbos algoritmos realizan exactamente el mismo n√∫mero de comparaciones en estos conjuntos. Esto se podr√≠a explicar debido a que ambos algoritmos de b√∫squeda siguen un principio similar, con la particularidad de que \\(B_2\\) aumenta el rango de b√∫squeda de una manera m√°s agresiva.\nSon los m√°s eficientes computacionalmente en todos los casos. Esto respalda su mejor desempe√±o en tiempo observado en la Tabla 1.\n\n\n\n4. BK (Barbay-Kenyon)\n\nRealiza menos comparaciones que \\(ME\\), pero m√°s que las variantes de Baeza-Yates.\nEn tripletas, hace incluso m√°s comparaciones que \\(BY\\) Bisecci√≥n, lo cual coincide con su tiempo m√°s alto en ese caso.\n\n\n\n\nTabla 3. Longitudes de las intersecciones resultantes para cada conjunto y algoritmo.\n\\[\n\\begin{array}{|l|c|c|c|}\n\\hline\n\\textbf{Longitud} & \\textbf{Conjunto (A)}\\ \\text{pares} & \\textbf{Conjunto (B)}\\ \\text{tripletas} & \\textbf{Conjunto (C)}\\ \\text{cu√°druples} \\\\\n\\hline\n\\text{ME} & 3627 & 4723 & 1550 \\\\\n\\text{BY Bisecci√≥n} & 3627 & 4723 & 1550 \\\\\n\\text{BY } B_{1} & 3627 & 4723 & 1550 \\\\\n\\text{BY } B_{2} & 3627 & 4723 & 1550 \\\\\n\\text{BK} & 3770 & 4763 & 1637 \\\\\n\\hline\n\\end{array}\n\\]\nDe la Tabla 3, se identifica lo siguiente:\n\n1. ME, BY Bisecci√≥n, BY \\(B_1\\) y BY \\(B_2\\)\n\nProducen exactamente la misma cantidad de resultados para cada conjunto.\nDebido a la consistencia, probablemente representan el resultado esperado.\n\n\n\n2. BK (Barbay-Kenyon)\n\nPara este algoritmo se identific√≥ una anomal√≠a; entrega m√°s resultados en todos los casos:\n\n+143 en pares, +40 en tripletas, +87 en cu√°druples.\n\nEsto podr√≠a significar:\n\nQue \\(BK\\) incluye falsos positivos.\nO que las otras implementaciones est√°n filtrando de m√°s. Esto parece poco probable dado que el resto de algoritmos coinciden.\n\n\n\nusing Pkg\nPkg.add(\"StatsPlots\")\nPkg.add(\"DataFrames\")\n\n\nusing StatsPlots\nusing DataFrames\n\n# Nombres de los conjuntos\nsets = [\"A\", \"B\", \"C\"]\nalgoritmos = [\"ME\", \"BY Bisecci√≥n\", \"BY B‚ÇÅ\", \"BY B‚ÇÇ\", \"BK\"]\n\n# Repetimos los nombres de conjunto y algoritmo\nset_labels = repeat(sets, inner=5)\nalg_labels = repeat(algoritmos, outer=3)\n\n# Tiempos en segundos (Tabla 1)\ntiempos = [\n    0.072497, 0.687597, 0.138168, 0.126267, 0.472339,  # A\n    0.131184, 0.305697, 0.115626, 0.106735, 0.2474,    # B\n    0.221043, 0.244972, 0.098732, 0.086077, 0.18608    # C\n]\n\n# Comparaciones (Tabla 2)\ncomparaciones = [\n    3238899, 236662, 229942, 229942, 316355,     # A\n    5276587, 478929, 400028, 400028, 857660,     # B\n    4261034, 270415, 235415, 235415, 460476      # C\n]\n\n# Longitudes de las intersecciones (Tabla 3)\nlongitudes = [\n    3627, 3627, 3627, 3627, 3770,     # A\n    4723, 4723, 4723, 4723, 4763,     # B\n    1550, 1550, 1550, 1550, 1637      # C\n]\n\n# DataFrame combinado\ndf = DataFrame(\n    Conjunto = set_labels,\n    Algoritmo = alg_labels,\n    Tiempo = tiempos,\n    Comparaciones = comparaciones,\n    Longitud = longitudes\n)\n\n15√ó5 DataFrame\n\n\n\nRow\nConjunto\nAlgoritmo\nTiempo\nComparaciones\nLongitud\n\n\n\nString\nString\nFloat64\nInt64\nInt64\n\n\n\n\n1\nA\nME\n0.072497\n3238899\n3627\n\n\n2\nA\nBY Bisecci√≥n\n0.687597\n236662\n3627\n\n\n3\nA\nBY B‚ÇÅ\n0.138168\n229942\n3627\n\n\n4\nA\nBY B‚ÇÇ\n0.126267\n229942\n3627\n\n\n5\nA\nBK\n0.472339\n316355\n3770\n\n\n6\nB\nME\n0.131184\n5276587\n4723\n\n\n7\nB\nBY Bisecci√≥n\n0.305697\n478929\n4723\n\n\n8\nB\nBY B‚ÇÅ\n0.115626\n400028\n4723\n\n\n9\nB\nBY B‚ÇÇ\n0.106735\n400028\n4723\n\n\n10\nB\nBK\n0.2474\n857660\n4763\n\n\n11\nC\nME\n0.221043\n4261034\n1550\n\n\n12\nC\nBY Bisecci√≥n\n0.244972\n270415\n1550\n\n\n13\nC\nBY B‚ÇÅ\n0.098732\n235415\n1550\n\n\n14\nC\nBY B‚ÇÇ\n0.086077\n235415\n1550\n\n\n15\nC\nBK\n0.18608\n460476\n1637\n\n\n\n\n\n\n\n# Gr√°fico 1: Tiempo\n@df df boxplot(\n    :Conjunto, :Tiempo,\n    title = \"Fig 1. Distribuci√≥n de tiempo por conjunto\",\n    ylabel = \"Tiempo (s)\",\n    notch = false\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigura 1. Corresponde a los tiempos de ejecuci√≥n. Muestra los ‚Äúboxplots‚Äù de mayor variabilidad. Se puede observar que para el conjunto A, se aprecia un rango m√°s amplio, esto se debe principalmente a que para este conjunto se registraron tanto el tiempo de ejecuci√≥n m√°s corto (\\(ME\\)) como el m√°s largo (\\(BY\\) Bisecci√≥n). Para los conjuntos B y C se muestran ‚Äúboxplots‚Äù muy compactos que muestran la poca variabilidad en tiempos de ejecuci√≥n.\nSe destaca que, si bien, existe algo de variabilidad principalmente para el conjunto A, en todos los casos los tiempos de ejecuci√≥n permanecieron en el mismo orden de magnitud.\n\n# Gr√°fico 2: Comparaciones\n@df df boxplot(\n    :Conjunto, :Comparaciones,\n    title = \"Fig 2. Distribuci√≥n de comparaciones por conjunto\",\n    ylabel = \"N√∫mero de comparaciones\",\n    notch = false\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigura 2. Corresponde a las comparaciones realizadas por conjunto. Se muestra para los tres conjuntos una variabilidad muy baja, lo que indica que en la gran mayor√≠a de casos se realiz√≥ un n√∫mero similar de comparaciones. Sin embargo, despliega claros ‚Äúoutliers‚Äù de apr√≥ximadamente un orden de magnitud mayor, que corresponden al algortimo \\(ME\\). Como ya se ha comentado este inspecciona todos los elementos de ambas listas.\n\n# Gr√°fico 3: Longitud total\n@df df boxplot(\n    :Conjunto, :Longitud,\n    title = \"Fig 3.Distribuci√≥n de longitudes de intersecci√≥n por conjunto\",\n    ylabel = \"Suma de longitudes\",\n    notch = false\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigura 3. Corresponde a la logitud de las intersecciones por conjunto. No hay variabilidad, esto es porque en teor√≠a todos los algoritmos deben llegar al mismo resultado, expresado en la longitud de los conjuntos de intersecci√≥n, cosa que en la pr√°ctica se dio. Con la √∫nica excepci√≥n del algoritmo \\(BK\\), que devovi√≥ una cantidad mayor de elementos para las intersecciones, esto se muestra como los valores ‚Äúoutliers‚Äù en los ‚Äúboxplots‚Äù. Vale la pena destacar que incluso s√≠ \\(BK\\) mostr√≥ valores at√≠picos, estos est√°n muy cerca de los resultados esperados"
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html",
    "href": "VillegasJoseAlbertoU3-T1.html",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "",
    "text": "Jos√© Alberto Villegas D√≠az Disciplina"
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html#introducci√≥n.",
    "href": "VillegasJoseAlbertoU3-T1.html#introducci√≥n.",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "Introducci√≥n.",
    "text": "Introducci√≥n.\nEl ordenamiento es el proceso computacional de reorganizar una secuencia dada de elementos en orden ascendente o descendente. (Estivill-Castro & Wood, 1992).\nEn este reporte, se implementar√°n y analizar√°n varios algoritmos cl√°sicos de ordenamiento por comparaci√≥n, a saber: Heapsort, Mergesort, Quicksort, y Bubblesort. Cada uno de estos algoritmos se caracteriza por distintas complejidades de tiempo y estrategias de partici√≥n de los datos, lo que los hace m√°s o menos eficientes seg√∫n las caracter√≠sticas del conjunto de datos a ordenar.\nPara hacerlo se usar√°n diferentes archivos proporcionados cuyos niveles de desorden son variables. Se realizar√° la m√©trica del n√∫mero de comparaciones as√≠ como del tiempo necesario para ordenarlos.\nEl an√°lisis se llevar√° a cabo utilizando archivos de entrada con niveles de desorden variados, lo que permitir√° observar c√≥mo se comportan los algoritmos en distintos tipos de distribuciones de los datos. Se emplear√°n tres m√©tricas principales para evaluar el desempe√±o de cada algoritmo: el n√∫mero de comparaciones realizadas, el n√∫mero de intercambio y el tiempo total de ejecuci√≥n."
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html#m√©todo-heapsort.",
    "href": "VillegasJoseAlbertoU3-T1.html#m√©todo-heapsort.",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "M√©todo heapsort.",
    "text": "M√©todo heapsort.\nDe acuerdo con Cormen et al.(2022) Heapsort introduce el uso de una estructura de datos llamada heap (mont√≠culo), que no solo es √∫til para el algoritmo de ordenaci√≥n. El algoritmo funciona construyendo el heap a partir de la lista y extrae repetidamente el elemento m√°ximo (o m√≠nimo) del mont√≠culo para construir la lista ordenada. Una de sus ventajas respecto a otros algoritmos de ordenamiento por comparaci√≥n, es que realiza el mismo in situ lo que significa que solo requiere un n√∫mero constante de elementos fuera del array de entrada en cualquier momento (Cormen et al.¬†2022).\nComplejidad temporal:\n\\(O(n \\log n)\\) en todos los casos.\nEsto significa que sin importar el orden preexistente en los arreglos, su complejidad permanecer√° constante.\n\nusing JSON\nusing Dates\n\n# Funci√≥n para ajustar el mont√≠culo (heapify) - √çndices basados en 1\nfunction heapify!(arr, n, i, counters)\n    largest = i\n    left = 2 * i      # Hijo izquierdo (ajustado para base 1)\n    right = 2 * i + 1 # Hijo derecho (ajustado para base 1)\n\n    # Comparar con el hijo izquierdo\n    counters[:comparisons] += 1\n    if left &lt;= n && arr[left] &gt; arr[largest]\n        largest = left\n    end\n\n    # Comparar con el hijo derecho\n    counters[:comparisons] += 1\n    if right &lt;= n && arr[right] &gt; arr[largest]\n        largest = right\n    end\n\n    # Si el mayor no es la ra√≠z, intercambiar y seguir ajustando\n    if largest != i\n        arr[i], arr[largest] = arr[largest], arr[i]\n        counters[:swaps] += 1\n        heapify!(arr, n, largest, counters)\n    end\nend\n\n# Implementaci√≥n de HeapSort - √çndices basados en 1\nfunction heapsort!(arr)\n    n = length(arr)\n    counters = Dict(:comparisons =&gt; 0, :swaps =&gt; 0)  # Contador de operaciones\n\n    # Construir el max-heap\n    for i in n √∑ 2:-1:1\n        heapify!(arr, n, i, counters)\n    end\n\n    # Extraer elementos del heap uno por uno\n    for i in n:-1:2\n        arr[1], arr[i] = arr[i], arr[1]  # Mover la ra√≠z al final\n        counters[:swaps] += 1\n        heapify!(arr, i - 1, 1, counters)\n    end\n\n    return counters\nend\n\n# Funci√≥n para cargar y ordenar el archivo JSON con m√∫ltiples claves\nfunction eval_heap(p::String)\n    # Construir la ruta del archivo con el argumento p\n    ruta_archivo = joinpath(homedir(),  raw\"C:\\Users\\josea\\Downloads\\listas-posteo-con-perturbaciones\", \"listas-posteo-con-perturbaciones-p=\" * p * \".json\")\n\n    # Cargar el archivo JSON\n    datos = JSON.parsefile(ruta_archivo)\n    contador = 0\n    contador2= 0\n\n    # Procesar cada clave del JSON\n    for (clave, arr) in datos\n\n        counters = heapsort!(arr)\n        contador += counters[:comparisons]\n        contador2 += counters[:swaps]\n    end\nprintln(\"Comparaciones: \", contador)\nprintln(\"Intercambios: \", contador2)\nend\n\neval_heap (generic function with 1 method)\n\n\n\nusing JSON\nusing Dates\n\n# Funci√≥n para ajustar el mont√≠culo (heapify) - √çndices basados en 1\nfunction heapify!(arr, n, i, counters)\n    largest = i\n    left = 2 * i      # Hijo izquierdo (ajustado para base 1)\n    right = 2 * i + 1 # Hijo derecho (ajustado para base 1)\n\n    # Comparar con el hijo izquierdo\n    counters[:comparisons] += 1\n    if left &lt;= n && arr[left] &gt; arr[largest]\n        largest = left\n    end\n\n    # Comparar con el hijo derecho\n    counters[:comparisons] += 1\n    if right &lt;= n && arr[right] &gt; arr[largest]\n        largest = right\n    end\n\n    # Si el mayor no es la ra√≠z, intercambiar y seguir ajustando\n    if largest != i\n        arr[i], arr[largest] = arr[largest], arr[i]\n        counters[:swaps] += 1\n        heapify!(arr, n, largest, counters)\n    end\nend\n\n# Implementaci√≥n de HeapSort - √çndices basados en 1\nfunction heapsort!(arr)\n    n = length(arr)\n    counters = Dict(:comparisons =&gt; 0, :swaps =&gt; 0)  # Contador de operaciones\n\n    # Construir el max-heap\n    for i in n √∑ 2:-1:1\n        heapify!(arr, n, i, counters)\n    end\n\n    # Extraer elementos del heap uno por uno\n    for i in n:-1:2\n        arr[1], arr[i] = arr[i], arr[1]  # Mover la ra√≠z al final\n        counters[:swaps] += 1\n        heapify!(arr, i - 1, 1, counters)\n    end\n\n    return counters\nend\n\n# Funci√≥n para cargar y ordenar el archivo JSON con m√∫ltiples claves\nfunction eval_heap(p::String)\n    # Construir la ruta del archivo con el argumento p\n    ruta_archivo = joinpath(homedir(),  raw\"C:\\Users\\josea\\Downloads\\listas-posteo-con-perturbaciones\", \"listas-posteo-con-perturbaciones-p=\" * p * \".json\")\n\n    # Cargar el archivo JSON\n    datos = JSON.parsefile(ruta_archivo)\n    contador = 0\n    contador2= 0\n\n    # Procesar cada clave del JSON\n    for (clave, arr) in datos\n\n        counters = heapsort!(arr)\n        contador += counters[:comparisons]\n        contador2 += counters[:swaps]\n    end\nprintln(\"Comparaciones: \", contador)\nprintln(\"Intercambios: \", contador2)\nend\n\neval_heap (generic function with 1 method)\n\n\n\n# Ejecutar el programa para p=016\n\n@time begin\n    eval_heap(\"016\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_heap(\"016\")\nend\n\nComparaciones: 4830498\nIntercambios: 2319348\n  0.487989 seconds (254.80 k allocations: 10.922 MiB, 29.39% gc time, 23.16% compilation time)\nComparaciones: 4830498\nIntercambios: 2319348\n  0.207115 seconds (191.69 k allocations: 7.581 MiB, 5.55% gc time)\n\n\n\n# Ejecutar el programa para p=032\n\n@time begin\n    eval_heap(\"032\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_heap(\"032\")\nend\n\nComparaciones: 4826432\nIntercambios: 2317315\n  0.181611 seconds (191.68 k allocations: 7.581 MiB)\nComparaciones: 4826432\nIntercambios: 2317315\n  0.245424 seconds (191.68 k allocations: 7.581 MiB, 1.72% gc time)\n\n\n\n# Ejecutar el programa para p=064\n\n@time begin\n    eval_heap(\"064\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_heap(\"064\")\nend\n\nComparaciones: 4820024\nIntercambios: 2314111\n  0.214752 seconds (191.55 k allocations: 7.572 MiB, 2.19% gc time)\nComparaciones: 4820024\nIntercambios: 2314111\n  0.213742 seconds (191.67 k allocations: 7.580 MiB, 0.48% gc time)\n\n\n\n# Ejecutar el programa para p=128\n\n@time begin\n    eval_heap(\"128\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_heap(\"128\")\nend\n\nComparaciones: 4805308\nIntercambios: 2306753\n  0.194435 seconds (191.55 k allocations: 7.572 MiB, 0.76% gc time)\nComparaciones: 4805308\nIntercambios: 2306753\n  0.180788 seconds (191.67 k allocations: 7.581 MiB, 0.63% gc time)\n\n\n\n# Ejecutar el programa para p=256\n\n@time begin\n    eval_heap(\"256\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_heap(\"256\")\nend\n\nComparaciones: 4783464\nIntercambios: 2295831\n  0.181757 seconds (191.56 k allocations: 7.572 MiB, 0.87% gc time)\nComparaciones: 4783464\nIntercambios: 2295831\n  0.176678 seconds (191.68 k allocations: 7.581 MiB, 0.79% gc time)\n\n\n\n# Ejecutar el programa para p=512\n\n@time begin\n    eval_heap(\"512\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_heap(\"512\")\nend\n\nComparaciones: 4752240\nIntercambios: 2280219\n  0.182473 seconds (191.55 k allocations: 7.572 MiB, 0.80% gc time)\nComparaciones: 4752240\nIntercambios: 2280219\n  0.182040 seconds (191.67 k allocations: 7.580 MiB, 0.72% gc time)"
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html#mergesort",
    "href": "VillegasJoseAlbertoU3-T1.html#mergesort",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "Mergesort",
    "text": "Mergesort\nEl algoritmo Mergesort se basa en una operaci√≥n simple llamada mezcla (merging), que consiste en combinar dos arreglos ordenados para formar un √∫nico arreglo ordenado. Este proceso da lugar a un m√©todo recursivo sencillo: para ordenar un arreglo, se divide en dos mitades, se ordenan recursivamente ambas mitades y luego se combinan los resultados mediante la operaci√≥n de mezcla (Sedgewick & Wayne, 2011). Uno de los principales atractivos de Mergesort es que garantiza ordenar cualquier arreglo de \\(n\\) elementos en un tiempo proporcional a \\(O(n \\log n)\\) Sin embargo, su desventaja principal es que requiere espacio adicional proporcional a \\(n\\) (Sedgewick & Wayne, 2011).\nComplejidad temporal:\n\\(O(n \\log n)\\) en todos los casos.\n\nusing JSON\nusing Dates\n\n# Funci√≥n para combinar dos subarreglos ordenados\nfunction merge!(arr, left, mid, right, counters)\n    # Tama√±os de los subarreglos\n    n1 = mid - left + 1\n    n2 = right - mid\n\n    # Crear arreglos temporales\n    L = copy(arr[left:left+n1-1])\n    R = copy(arr[mid+1:mid+n2])\n\n    i = 1  # √çndice para L\n    j = 1  # √çndice para R\n    k = left  # √çndice para arr\n\n    # Combinar los subarreglos\n    while i &lt;= n1 && j &lt;= n2\n        counters[:comparisons] += 1\n        if L[i] &lt;= R[j]\n            arr[k] = L[i]\n            i += 1\n        else\n            arr[k] = R[j]\n            j += 1\n        end\n        counters[:movements] += 1\n        k += 1\n    end\n\n    # Copiar elementos restantes de L, si los hay\n    while i &lt;= n1\n        arr[k] = L[i]\n        counters[:movements] += 1\n        i += 1\n        k += 1\n    end\n\n    # Copiar elementos restantes de R, si los hay\n    while j &lt;= n2\n        arr[k] = R[j]\n        counters[:movements] += 1\n        j += 1\n        k += 1\n    end\nend\n\n# Implementaci√≥n de MergeSort\nfunction mergesort!(arr, left, right, counters)\n    if left &lt; right\n        mid = (left + right) √∑ 2\n        mergesort!(arr, left, mid, counters)\n        mergesort!(arr, mid + 1, right, counters)\n        merge!(arr, left, mid, right, counters)\n    end\nend\n\n# Wrapper para inicializar MergeSort con contadores\nfunction mergesort_wrapper!(arr)\n    counters = Dict(:comparisons =&gt; 0, :movements =&gt; 0)\n    mergesort!(arr, 1, length(arr), counters)\n    return counters\nend\n\n# Cargar y ordenar el archivo JSON con m√∫ltiples claves\nfunction eval_merge(p::String)\n    # Construir la ruta del archivo con el argumento p\n    ruta_archivo = joinpath(homedir(),  raw\"C:\\Users\\josea\\Downloads\\listas-posteo-con-perturbaciones\", \"listas-posteo-con-perturbaciones-p=\" * p * \".json\")\n\n    # Cargar el archivo JSON\n    datos = JSON.parsefile(ruta_archivo)\n    contador = 0\n    contador2= 0\n\n    # Procesar cada clave del JSON\n    for (clave, arr) in datos\n\n        counters = mergesort_wrapper!(arr)\n        contador += counters[:comparisons]\n        contador2 += counters[:movements]\n    end\nprintln(\"Comparaciones: \", contador)\nprintln(\"Intercambios: \", contador2)\nend\n\neval_merge (generic function with 1 method)\n\n\n\n# Ejecutar el programa para p=016\n\n@time begin\n    eval_merge(\"016\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_merge(\"016\")\nend\n\nComparaciones: 1572444\nIntercambios: 2367713\n  0.232683 seconds (1.39 M allocations: 77.256 MiB, 12.19% gc time, 26.26% compilation time)\nComparaciones: 1572444\nIntercambios: 2367713\n  0.442377 seconds (1.34 M allocations: 75.157 MiB, 69.89% gc time)\n\n\n\n# Ejecutar el programa para p=032\n\n@time begin\n    eval_merge(\"032\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_merge(\"032\")\nend\n\nComparaciones: 1669236\nIntercambios: 2367713\n  0.169852 seconds (1.34 M allocations: 75.146 MiB, 14.78% gc time)\nComparaciones: 1669236\nIntercambios: 2367713\n  0.184990 seconds (1.34 M allocations: 75.156 MiB, 10.29% gc time)\n\n\n\n# Ejecutar el programa para p=064\n\n@time begin\n    eval_merge(\"064\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_merge(\"064\")\nend\n\nComparaciones: 1755354\nIntercambios: 2367713\n  0.188880 seconds (1.34 M allocations: 75.146 MiB, 23.22% gc time)\nComparaciones: 1755354\nIntercambios: 2367713\n  0.259645 seconds (1.34 M allocations: 75.155 MiB, 40.08% gc time)\n\n\n\n# Ejecutar el programa para p=128\n\n@time begin\n    eval_merge(\"128\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_merge(\"128\")\nend\n\nComparaciones: 1844035\nIntercambios: 2367713\n  0.169888 seconds (1.34 M allocations: 75.146 MiB, 12.87% gc time)\nComparaciones: 1844035\nIntercambios: 2367713\n  0.193641 seconds (1.34 M allocations: 75.155 MiB, 24.28% gc time)\n\n\n\n# Ejecutar el programa para p=256\n\n@time begin\n    eval_merge(\"256\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_merge(\"256\")\nend\n\nComparaciones: 1915028\nIntercambios: 2367713\n  0.281777 seconds (1.34 M allocations: 75.146 MiB, 41.46% gc time)\nComparaciones: 1915028\nIntercambios: 2367713\n  0.174015 seconds (1.34 M allocations: 75.155 MiB, 14.61% gc time)\n\n\n\n# Ejecutar el programa para p=512\n\n@time begin\n    eval_merge(\"512\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_merge(\"512\")\nend\n\nComparaciones: 1975697\nIntercambios: 2367713\n  0.208104 seconds (1.34 M allocations: 75.146 MiB, 24.63% gc time)\nComparaciones: 1975697\nIntercambios: 2367713\n  0.261640 seconds (1.34 M allocations: 75.155 MiB, 40.85% gc time)"
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html#quicksort",
    "href": "VillegasJoseAlbertoU3-T1.html#quicksort",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "Quicksort",
    "text": "Quicksort\nQuicksort es un algoritmo de ordenaci√≥n ampliamente utilizado que, a pesar de tener un tiempo de ejecuci√≥n en el peor caso de \\(O(n^2)\\) para un array de n elementos, es una de las opciones m√°s eficientes en la pr√°ctica. Esto se debe a que su tiempo de ejecuci√≥n promedio es \\(O(n \\log n)\\), con constantes ocultas en la notaci√≥n \\(O(n \\log n)\\) muy peque√±as, lo que lo hace extremadamente r√°pido en la mayor√≠a de los casos (Cormen et al.¬†2022). Adem√°s, Quicksort tiene la ventaja de ser un algoritmo in situ, es decir, ordena los elementos directamente en el array original sin requerir espacio adicional significativo. Esta caracter√≠stica lo hace especialmente adecuado para entornos de memoria virtual Funcionamiento (Cormen et al.¬†2022). Al igual que Mergesort, tambi√©n utiliza un enfoque ‚Äúdivide y vencer√°s‚Äù. Selecciona un elemento pivote y reorganiza la lista de manera que los elementos menores que el pivote est√©n a su izquierda y los mayores a su derecha. Luego, repite el proceso recursivamente para las sublistas (Cormen et al.¬†2022).\nAunque Quicksort no es adaptativo por dise√±o (es decir, no aprovecha el orden existente en la entrada), se han desarrollado versiones adaptativas de Quicksort, como CKsort, que utiliza una t√©cnica de divisi√≥n espec√≠fica (Cook-Kim division) para mejorar su rendimiento en secuencias casi ordenadas(Estivill-Castro & Wood, 1992).\nComplejidad temporal:\nPeor caso:\n\\(O(n^2)\\) ( depende del pivote)\nCaso promedio:\n\\(O(n \\log n)\\)\n\nusing JSON\nusing Dates\n\n# Funci√≥n para particionar el arreglo usando el √∫ltimo elemento como pivote\nfunction partition!(arr, low, high, counters)\n    pivot = arr[high]\n    i = low - 1  # √çndice del elemento menor\n\n    for j in low:high-1\n        counters[:comparisons] += 1\n        if arr[j] &lt;= pivot\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n            counters[:swaps] += 1\n        end\n    end\n\n    # Colocar el pivote en su posici√≥n correcta\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    counters[:swaps] += 1\n    return i + 1\nend\n\n# Implementaci√≥n de QuickSort\nfunction quicksort!(arr, low, high, counters)\n    if low &lt; high\n        # Obtener el √≠ndice de partici√≥n\n        pi = partition!(arr, low, high, counters)\n        \n        # Ordenar las particiones recursivamente\n        quicksort!(arr, low, pi - 1, counters)\n        quicksort!(arr, pi + 1, high, counters)\n    end\nend\n\n# Wrapper para inicializar QuickSort con contadores\nfunction quicksort_wrapper!(arr)\n    counters = Dict(:comparisons =&gt; 0, :swaps =&gt; 0)\n    quicksort!(arr, 1, length(arr), counters)\n    return counters\nend\n\n# Cargar y ordenar el archivo JSON con m√∫ltiples claves\nfunction eval_quick(p::String)\n    # Construir la ruta del archivo con el argumento p\n    ruta_archivo = joinpath(homedir(),  raw\"C:\\Users\\josea\\Downloads\\listas-posteo-con-perturbaciones\", \"listas-posteo-con-perturbaciones-p=\" * p * \".json\")\n\n    # Cargar el archivo JSON\n    datos = JSON.parsefile(ruta_archivo)\n    contador = 0\n    contador2= 0\n\n    # Procesar cada clave del JSON\n    for (clave, arr) in datos\n\n        counters = quicksort_wrapper!(arr)\n        contador += counters[:comparisons]\n        contador2 += counters[:swaps]\n    end\nprintln(\"Comparaciones: \", contador)\nprintln(\"Intercambios: \", contador2)\nend\n\neval_quick (generic function with 1 method)\n\n\n\n# Ejecutar el programa para p=016\n\n@time begin\n    eval_quick(\"016\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_quick(\"016\")\nend\n\nComparaciones: 238991206\nIntercambios: 132394039\n  8.545927 seconds (219.99 k allocations: 8.957 MiB, 0.11% gc time, 0.43% compilation time)\nComparaciones: 238991206\nIntercambios: 132394039\n  8.226709 seconds (191.67 k allocations: 7.581 MiB, 0.07% gc time)\n\n\n\n# Ejecutar el programa para p=032\n\n@time begin\n    eval_quick(\"032\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_quick(\"032\")\nend\n\nComparaciones: 155831691\nIntercambios: 109338692\n  5.753984 seconds (191.55 k allocations: 7.572 MiB, 0.09% gc time)\nComparaciones: 155831691\nIntercambios: 109338692\n  5.646577 seconds (191.67 k allocations: 7.581 MiB, 0.01% gc time)\n\n\n\n# Ejecutar el programa para p=064\n\n@time begin\n    eval_quick(\"064\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_quick(\"064\")\nend\n\nComparaciones: 100831274\nIntercambios: 78513669\n  3.923298 seconds (191.56 k allocations: 7.572 MiB, 2.24% gc time)\nComparaciones: 100831274\nIntercambios: 78513669\n  3.760600 seconds (191.68 k allocations: 7.581 MiB)\n\n\n\n# Ejecutar el programa para p=128\n\n@time begin\n    eval_quick(\"128\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_quick(\"128\")\nend\n\nComparaciones: 28777425\nIntercambios: 16890882\n  1.128812 seconds (191.55 k allocations: 7.572 MiB, 0.28% gc time)\nComparaciones: 28777425\nIntercambios: 16890882\n  1.055082 seconds (191.68 k allocations: 7.581 MiB, 0.42% gc time)\n\n\n\n# Ejecutar el programa para p=256\n\n@time begin\n    eval_quick(\"256\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_quick(\"256\")\nend\n\nComparaciones: 18675607\nIntercambios: 6596669\n  0.638336 seconds (191.68 k allocations: 7.580 MiB)\nComparaciones: 18675607\nIntercambios: 6596669\n  0.625922 seconds (191.67 k allocations: 7.581 MiB, 0.29% gc time)\n\n\n\n# Ejecutar el programa para p=512\n\n@time begin\n    eval_quick(\"512\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_quick(\"512\")\nend\n\nComparaciones: 11725369\nIntercambios: 7020554\n  0.445251 seconds (191.55 k allocations: 7.572 MiB, 0.18% gc time)\nComparaciones: 11725369\nIntercambios: 7020554\n  0.461213 seconds (191.68 k allocations: 7.581 MiB, 0.42% gc time)"
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html#bubblesort",
    "href": "VillegasJoseAlbertoU3-T1.html#bubblesort",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "Bubblesort",
    "text": "Bubblesort\nFuncionamiento: Compara pares de elementos adyacentes y los intercambia si est√°n en el orden incorrecto. Este proceso se repite hasta que no se necesiten m√°s intercambios. Es un algortimo adaptativo ya que es sensible al orden preexistente del arreglo.\nComplejidad temporal:\nPeor caso:\n\\(O(n^2)\\)\nMejor caso:\n\\(O(n)\\) (si la lista ya est√° ordenada)\n\nusing JSON\nusing Dates\n\n# Implementaci√≥n de BubbleSort\nfunction bubblesort!(arr)\n    n = length(arr)\n    counters = Dict(:comparisons =&gt; 0, :swaps =&gt; 0)  # Contador de operaciones\n    swapped = false\n\n    for i in 1:n-1\n        swapped = false\n        for j in 1:n-i\n            counters[:comparisons] += 1\n            if arr[j] &gt; arr[j+1]\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n                counters[:swaps] += 1\n                swapped = true\n            end\n        end\n        # Si no hubo intercambios en esta pasada, el arreglo ya est√° ordenado\n        if !swapped\n            break\n        end\n    end\n\n    return counters\nend\n\n# Cargar y ordenar el archivo JSON con m√∫ltiples claves\nfunction eval_bubble(p::String)\n    # Construir la ruta del archivo con el argumento p\n    ruta_archivo = joinpath(homedir(),  raw\"C:\\Users\\josea\\Downloads\\listas-posteo-con-perturbaciones\", \"listas-posteo-con-perturbaciones-p=\" * p * \".json\")\n\n    # Cargar el archivo JSON\n    datos = JSON.parsefile(ruta_archivo)\n    contador = 0\n    contador2= 0\n\n    # Procesar cada clave del JSON\n    for (clave, arr) in datos\n\n        counters = bubblesort!(arr)\n        contador += counters[:comparisons]\n        contador2 += counters[:swaps]\n    end\nprintln(\"Comparaciones: \", contador)\nprintln(\"Intercambios: \", contador2)\nend\n\neval_bubble (generic function with 1 method)\n\n\n\n# Ejecutar el programa para p=016\n\n@time begin\n    eval_bubble(\"016\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_bubble(\"016\")\nend\n\nComparaciones: 1239423690\nIntercambios: 1951394\n 35.737679 seconds (217.12 k allocations: 8.829 MiB, 0.01% gc time, 0.08% compilation time)\nComparaciones: 1239423690\nIntercambios: 1951394\n 35.802825 seconds (191.68 k allocations: 7.581 MiB, 0.02% gc time)\n\n\n\n# Ejecutar el programa para p=032\n\n@time begin\n    eval_bubble(\"032\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_bubble(\"032\")\nend\n\nComparaciones: 1230370900\nIntercambios: 4024541\n 35.331065 seconds (191.56 k allocations: 7.572 MiB, 0.02% gc time)\nComparaciones: 1230370900\nIntercambios: 4024541\n 34.921086 seconds (191.69 k allocations: 7.581 MiB, 0.00% gc time)\n\n\n\n# Ejecutar el programa para p=064\n\n@time begin\n    eval_bubble(\"064\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_bubble(\"064\")\nend\n\nComparaciones: 1290738623\nIntercambios: 7686291\n 36.387142 seconds (191.56 k allocations: 7.572 MiB, 0.00% gc time)\nComparaciones: 1290738623\nIntercambios: 7686291\n 40.992388 seconds (191.68 k allocations: 7.581 MiB, 0.00% gc time)\n\n\n\n# Ejecutar el programa para p=128\n\n@time begin\n    eval_bubble(\"128\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_bubble(\"128\")\nend\n\nComparaciones: 1302028794\nIntercambios: 14702835\n 37.817800 seconds (191.56 k allocations: 7.572 MiB, 0.00% gc time)\nComparaciones: 1302028794\nIntercambios: 14702835\n 37.637456 seconds (191.68 k allocations: 7.581 MiB, 0.00% gc time)\n\n\n\n# Ejecutar el programa para p=256\n\n@time begin\n    eval_bubble(\"256\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_bubble(\"256\")\nend\n\nComparaciones: 1306702501\nIntercambios: 26925715\n 37.682648 seconds (191.55 k allocations: 7.572 MiB, 0.00% gc time)\nComparaciones: 1306702501\nIntercambios: 26925715\n 37.965850 seconds (191.68 k allocations: 7.581 MiB, 0.00% gc time)\n\n\n\n# Ejecutar el programa para p=512\n\n@time begin\n    eval_bubble(\"512\")\nend\n# Se ejecuta dos veces para no considerar el tiempo de compilaci√≥n \n@time begin\n    eval_bubble(\"512\")\nend\n\nComparaciones: 1308817164\nIntercambios: 48656147\n 38.155156 seconds (191.54 k allocations: 7.572 MiB, 0.00% gc time)\nComparaciones: 1308817164\nIntercambios: 48656147\n 38.810830 seconds (191.67 k allocations: 7.581 MiB, 0.00% gc time)"
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html#resultados-y-discusi√≥n",
    "href": "VillegasJoseAlbertoU3-T1.html#resultados-y-discusi√≥n",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "Resultados y discusi√≥n",
    "text": "Resultados y discusi√≥n\nTabla 1. N√∫mero de comparaciones por algoritmo de ordenamiento\n\n\n\\[\\begin{array}{|c|c|c|c|c|}\n\\hline\n\\textbf{Perturbaci√≥n} & \\textbf{Heapsort} & \\textbf{Mergesort} & \\textbf{Quicksort} & \\textbf{Bubblesort} \\\\\n\\hline\n16 & 4,830,498 & 1,572,444 & 238,991,206 & 1,239,423,690 \\\\\n32 & 4,826,432 & 1,669,236 & 155,831,691 & 1,230,370,900 \\\\\n64 & 4,820,024 & 1,755,354 & 100,831,274 & 1,290,738,623 \\\\\n128 & 4,805,308 & 1,844,035 & 28,777,425 & 1,302,028,794 \\\\\n256 & 4,783,464 & 1,915,028 & 18,675,607 & 1,306,702,501 \\\\\n512 & 4,752,240 & 1,975,697 & 11,725,369 & 1,308,817,164 \\\\\n\\hline\n\\end{array}\\]\nDe la tabla 1 podemos observar que tanto Mergesort como Heapsort, mantuvieron n√∫meros de comparaciones muy similares, debemos recordar que estos dos algoritmos de ordenamiento tienen complejidades de \\(O(n \\log n)\\) en todos los casos, por lo que sin importar el nivel de perturbaci√≥n en cada archivo las comparaciones que realiz√≥ el algoritmo fueron pr√°cticamente iguales en cada caso.\nEn el caso de Quicksort, su complejidad depende del pivote seleccionado, para el experimento se eligi√≥ el √∫ltimo elemento de cada lista de tal forma que durante la partici√≥n, el arreglo se reorganiza de manera que los elementos menores que el pivote queden a la izquierda y los elementos mayores queden a la derecha, por lo que si el arreglo est√° casi ordenado, el pivote ser√° el elemento m√°s grande. Como resultado, la partici√≥n no ser√° eficiente y har√° que la complejidad del algortimo tienda a \\(O(n^2)\\). Esto es verificable en la tabla de resultados donde se muestra que mientras menos desordenados estaban los arreglos el n√∫mero de comparaciones fue mayor.\nFinalmente para Bubblesort, se puede apreciar que de todos los algoritmos fue el que mayor n√∫mero de comparaciones requiri√≥, debemos tambi√©n recordar que su complejidad var√≠a entre \\(O(n)\\) y \\(O(n^2)\\), y al ser un algortimo adaptativo se vuelve sensible al orden preexistente en los arreglos a ordenar. Esto se puede verificar en la tabla en la que podemos apreciar la tendencia clara a aumentar el n√∫mero de comparaciones conforme aumenta el desorden\nTabla 2. N√∫mero de intercambios por algoritmo de ordenamiento\n\\[\\begin{array}{|c|c|c|c|c|}\n\\hline\n\\textbf{Perturbaci√≥n} & \\textbf{Heapsort} & \\textbf{Mergesort} & \\textbf{Quicksort} & \\textbf{Bubblesort} \\\\\n\\hline\n16 & 2,319,348 & 2,367,713 & 132,394,039 & 1,951,394 \\\\\n32 & 2,317,315 & 2,367,713 & 109,338,692 & 4,024,541 \\\\\n64 & 2,314,111 & 2,367,713 & 78,513,669 & 7,686,291 \\\\\n128 & 2,306,753 & 2,367,713 & 16,890,882 & 14,702,835 \\\\\n256 & 2,295,831 & 2,367,713 & 6,596,669 & 26,925,715 \\\\\n512 & 2,280,219 & 2,367,713 & 7,020,554 & 48,656,147 \\\\\n\\hline\n\\end{array}\\]\nLa tabla 2 se puede interpretar bajo la misma l√≥gica de la tabla anterior los algoritmos de complejidad constante \\(O(n \\log n)\\), Heapsort y Mergesort manttuvieron valores de intercambios constantes, en particular Mergesort que mantuvo exactamente el mismo n√∫mero para cada caso. Quicksort al haber elegido el √∫ltimo elemento como pivote muestra un descenso de los intercambios necesarios conforme las entradas son m√°s desordenadas. Finalmente Bubblesort al ser un algoritmo adaptativo muestra un marcado incremento en el n√∫mero de intercambios necesarios conforme las entradas se tienen un mayor grado de perturbaci√≥n.\nTabla 3. Tiempos de ejecuci√≥n por algoritmo de ordenamiento en segundos\n\\[\\begin{array}{|c|c|c|c|c|}\n\\hline\n\\textbf{Perturbaci√≥n} & \\textbf{Heapsort} & \\textbf{Mergesort} & \\textbf{Quicksort} & \\textbf{Bubblesort} \\\\\n\\hline\n16 & 0.207115 & 0.442377 & 8.226709 & 35.802825 \\\\\n32 & 0.245424 & 0.184990 & 5.646577 & 34.921086 \\\\\n64 & 0.213742 & 0.259645 & 3.760600 & 40.992388 \\\\\n128 & 0.180788 & 0.193641 & 1.055082 & 37.637456 \\\\\n256 & 0.176678 & 0.174015 & 0.625922 & 37.965850 \\\\\n512 & 0.182040 & 0.261640 & 0.461213 & 38.810830 \\\\\n\\hline\n\\end{array}\\]\nFinalmente de la tabla 3 podemos observar que los mejores tiempos de ejecuci√≥n fueron para los algortimos de complejidad constante; Heapsort y Mergesort. Quicksort mostr√≥ tiempos de ejecuci√≥n de un orden superior e la mayor√≠a de los casos, pero en los casos de mayor desorden los tiempos son comparables. Finalmente Bubblesort mostr√≥ tiempos de ejecuci√≥n de hasta dos ordenes de magnitud mayores, lo que lo convierte en el algoritmo menos eficiente para este experimento."
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html#conclusiones",
    "href": "VillegasJoseAlbertoU3-T1.html#conclusiones",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "Conclusiones",
    "text": "Conclusiones\nEn conclusi√≥n, los resultados obtenidos y expresados en las tablas comparativas ofrecen una visi√≥n clara del rendimiento de los algoritmos evaluados en t√©rminos de comparaciones, intercambios y tiempos de ejecuci√≥n. Tanto Mergesort como Heapsort mostraron un rendimiento bastante constante en cuanto al n√∫mero de comparaciones, dado que son de complejidad constante \\(O(n \\log n)\\) esto refleja su eficiencia al manejar diferentes niveles de desorden en los datos. Esta eficiencia tambi√©n se refleja en los tiempos de ejecuci√≥n observados en la tabla 3, donde ambos algoritmos demostraron ser los m√°s r√°pidos, con tiempos de ejecuci√≥n estables y comparables a lo largo de los distintos niveles de desorden.\nPor otro lado, Quicksort mostr√≥ una mayor variabilidad en su n√∫mero de comparaciones, especialmente cuando los arreglos estaban casi ordenados. En estos casos, debido a la elecci√≥n del √∫ltimo elemento como pivote, la partici√≥n result√≥ ineficiente para los casos en los que los arreglos estaaban m√°s ordenados, pero eficiente para aquellos m√°s desordenados, esto tambi√©n se vio reflejado en sus tiempos de ejecuci√≥n. Aunque en los casos con mayor desorden, los tiempos de ejecuci√≥n de Quicksort fueron comparables a los de Mergesort y Heapsort, su desempe√±o sigue siendo menos predecible y m√°s dependiente del estado inicial de los datos.\nFinalmente, Bubblesort fue el algoritmo que requiri√≥ el mayor n√∫mero de comparaciones en todos los casos, lo que tambi√©n se reflej√≥ en sus tiempos de ejecuci√≥n. En los experimentos, Bubblesort mostr√≥ tiempos de ejecuci√≥n de hasta dos √≥rdenes de magnitud mayores que los de los otros algoritmos, lo que lo convierte en el algoritmo menos eficiente de todos en este experimento.\nEn resumen, los resultados destacan la superioridad de Mergesort y Heapsort tanto en t√©rminos de eficiencia en el n√∫mero de comparaciones como en tiempos de ejecuci√≥n, mientras que Quicksort, aunque competitivo en ciertos escenarios, puede ser sensible al desorden inicial de los datos, y Bubblesort sigue siendo el menos eficiente en especial para entradas con con mucho desorden preexistente."
  },
  {
    "objectID": "VillegasJoseAlbertoU3-T1.html#bibliograf√≠a",
    "href": "VillegasJoseAlbertoU3-T1.html#bibliograf√≠a",
    "title": "3A. Reporte escrito. Experimentos y an√°lisis de algoritmos de ordenamiento.",
    "section": "Bibliograf√≠a",
    "text": "Bibliograf√≠a\nCormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2022). Introduction to Algorithms (2nd ed.). MIT Press.\nEstivill-Castro, V., & Wood, D. (1992). A survey of adaptive sorting algorithms. ACM Computing Surveys, 24(4), 441-476. https://doi.org/10.1145/146370.146381\nSedgewick, R., & Wayne, K. (2011). Algorithms (4th ed.). Pearson Education, Inc."
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html",
    "href": "VillegasJoseAlberto-U2-T1.html",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "",
    "text": "Jos√© Alberto Villegas D√≠az Disciplina"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#definici√≥n-y-prueba-del-algoritmo",
    "href": "VillegasJoseAlberto-U2-T1.html#definici√≥n-y-prueba-del-algoritmo",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Definici√≥n y prueba del algoritmo",
    "text": "Definici√≥n y prueba del algoritmo\n\n# Funci√≥n para matrices aleatorias de tama√±o n x n\nfunction generar_matriz_aleatoria(n)\n    return rand(n, n)  # Matriz con n√∫meros aleatorios entre 0 y 1\nend\n\n# Funci√≥n en la que se implementa un algoritmo convencional para el producto de matrices\nfunction multiplicar_matrices(A, B)\n    n = size(A, 1)  #A y B son de tama√±o n x n\n    C = zeros(n, n)  # Matriz resultado en la que se asignar√°n los valores de cij\n    operaciones = 0  # Contador de operaciones\n\n    # Algoritmo de multiplicaci√≥n de matrices convencional\n    for i in 1:n\n        for j in 1:n\n            suma = 0  # Variable para la suma en la posici√≥n (i, j)\n            for k in 1:n\n                suma += A[i, k] * B[k, j]  # Multiplicaci√≥n y suma\n                operaciones += 1  # Contamos cada multiplicaci√≥n\n            end\n            C[i, j] = suma  # Asignamos el valor a la matriz resultado\n        end\n    end\n\n    return C, operaciones  # Retorna la matriz resultado y el n√∫mero de operaciones\nend\n\nmultiplicar_matrices (generic function with 1 method)\n\n\nUna vez definidas las funciones podemos realizar una validaci√≥n simple para matrices peque√±as de orden 3x3.\n\n# Validaci√≥n de uso con matrices 3x3\nn = 3  # Tama√±o de la matriz\nA = generar_matriz_aleatoria(n)\nB = generar_matriz_aleatoria(n)\n\n# Multiplicaci√≥n de matrices\nC, operaciones = multiplicar_matrices(A, B)\n\n# Mostrar el resultado\n\nprintln(\"Matriz A:\")\nprintln(A)\nprintln(\"Matriz B:\")\nprintln(B)\nprintln(\"Matriz C (Resultado):\")\nprintln(C)\n\n# Mostrar el n√∫mero de operaciones realizadas\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nMatriz A:\n[0.48776183234824144 0.6124433790334284 0.028635546875128703; 0.8370848622572715 0.7473292661917925 0.9877981495667337; 0.9735150429578445 0.19481858305396282 0.057932071864141954]\nMatriz B:\n[0.3442737221849198 0.8344937410238792 0.5451937807016894; 0.766291104724915 0.08561097205382118 0.6577453667078036; 0.9520486858842626 0.7301190823571463 0.9768559577402947]\nMatriz C (Resultado):\n[0.664495929835295 0.48037342841918884 0.696729316958151; 1.8012900205112459 1.483731941698228 1.9128623305140917; 0.539597547560282 0.8713681295588075 0.7154866567372042]\nN√∫mero de operaciones realizadas: 27\n\n\nLos algoritmos mostraron un correcto funcionamiento por lo que se proceder√° a evaluar para los distintos valores de \\(n\\). N√≥tese que para esta validaci√≥n se imprimieron las matrices, esto no es viable en los siguientes casos debido al tama√±o de las entradas."
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n100",
    "href": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n100",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Evaluaci√≥n para \\(n=100\\)",
    "text": "Evaluaci√≥n para \\(n=100\\)\n\n# Validaci√≥n de uso con matrices 100x100\nn = 100  # Tama√±o de la matriz\nA = generar_matriz_aleatoria(n)\nB = generar_matriz_aleatoria(n)\n\n# Multiplicaci√≥n de matrices\nC, operaciones = multiplicar_matrices(A, B)\n# Mostrar el n√∫mero de operaciones realizadas\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nN√∫mero de operaciones realizadas: 1000000\n\n\nSe puede observar que el n√∫mero de operaciones realizadas cuando \\(n=100\\) es de 1,000,000 es decir \\(100^3\\)\n\nusing BenchmarkTools\n@btime multiplicar_matrices(A, B)\n\n  825.900 Œºs (4 allocations: 78.23 KiB)\n\n\n([28.132338392688823 23.908113166359033 ‚Ä¶ 25.024304177684872 25.7096938977009; 26.667022471404753 23.660024037205346 ‚Ä¶ 24.639590229379817 26.44517290558687; ‚Ä¶ ; 26.002885424023155 22.99216990611572 ‚Ä¶ 23.492611418137535 24.916168129409794; 27.243874373771543 25.87820795626854 ‚Ä¶ 26.581182371428145 26.91368518219324], 1000000)"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n300",
    "href": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n300",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Evaluaci√≥n para \\(n=300\\)",
    "text": "Evaluaci√≥n para \\(n=300\\)\n\n# Validaci√≥n de uso con matrices 100x100\nn = 300  # Tama√±o de la matriz\nA = generar_matriz_aleatoria(n)\nB = generar_matriz_aleatoria(n)\n\n# Multiplicaci√≥n de matrices\nC, operaciones = multiplicar_matrices(A, B)\n# Mostrar el n√∫mero de operaciones realizadas\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nN√∫mero de operaciones realizadas: 27000000\n\n\nSe puede observar que el n√∫mero de operaciones realizadas cuando \\(n=300\\) es de 27,000,000 es decir \\(300^3\\)\n\nusing BenchmarkTools\n@btime multiplicar_matrices(A, B)\n\n  23.998 ms (4 allocations: 703.23 KiB)\n\n\n([80.53091461158125 77.91382521022068 ‚Ä¶ 78.23327276120801 77.15153895643374; 71.37048085506102 70.54930640968472 ‚Ä¶ 67.77446808097446 69.81725780702683; ‚Ä¶ ; 78.54949084586757 74.26211081012234 ‚Ä¶ 74.54586378001189 75.42220879028378; 72.79998868719915 72.28643983521658 ‚Ä¶ 71.78528089018043 70.06249995014716], 27000000)\n\n\nPodemos observar que el tiempo en el que increment√≥ fue apr√≥ximadamente de un orden m√°s respecto de \\(n=100\\) y el n√∫mero de asignaciones permanece constante"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n1000",
    "href": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n1000",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Evaluaci√≥n para \\(n=1000\\)",
    "text": "Evaluaci√≥n para \\(n=1000\\)\n\n# Validaci√≥n de uso con matrices 1000x1000\nn = 1000  # Tama√±o de la matriz\nA = generar_matriz_aleatoria(n)\nB = generar_matriz_aleatoria(n)\n\n# Multiplicaci√≥n de matrices\nC, operaciones = multiplicar_matrices(A, B)\n# Mostrar el n√∫mero de operaciones realizadas\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nN√∫mero de operaciones realizadas: 1000000000\n\n\nSe puede observar que el n√∫mero de operaciones realizadas cuando \\(n=1000\\) es de 1,000,000,000 es decir \\(1000^3\\)\n\nusing BenchmarkTools\n@btime multiplicar_matrices(A, B)\n\n  1.331 s (4 allocations: 7.63 MiB)\n\n\n([252.28375919010392 256.163478843609 ‚Ä¶ 255.81051340050507 252.5790668154193; 245.61903803038666 244.96190533494607 ‚Ä¶ 244.73860377052003 243.5577681299076; ‚Ä¶ ; 249.72986247348513 252.9162720651867 ‚Ä¶ 252.232903123629 244.19782743234276; 264.62505711595907 257.55400576599106 ‚Ä¶ 260.0656411956669 253.25510157969072], 1000000000)\n\n\nPodemos observar que el tiempo en el que increment√≥ fue apr√≥ximadamente de un orden m√°s respecto de \\(n=300\\) y el n√∫mero de asignaciones permanece constante"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#experimento-para-matrices-dispersas",
    "href": "VillegasJoseAlberto-U2-T1.html#experimento-para-matrices-dispersas",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Experimento para matrices dispersas",
    "text": "Experimento para matrices dispersas\n\nusing SparseArrays\n\nA = sprand(1000, 1000, 0.01)  # Matriz 1000x1000 con 1% de elementos no ceros\nB = sprand(1000, 1000, 0.01)\n# Multiplicaci√≥n de matrices\nC, operaciones = multiplicar_matrices(A, B)\n# Mostrar el n√∫mero de operaciones realizadas\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nN√∫mero de operaciones realizadas: 1000000000\n\n\n\nusing BenchmarkTools\n@btime multiplicar_matrices(A, B)\n\n  21.248 s (4 allocations: 7.63 MiB)\n\n\n([0.0 0.5179738303041588 ‚Ä¶ 0.0 0.0; 0.0 0.0 ‚Ä¶ 0.0 0.28833088395964407; ‚Ä¶ ; 0.0 0.0 ‚Ä¶ 0.0 0.0; 0.0 0.0 ‚Ä¶ 0.0 0.0], 1000000000)\n\n\nSe observa que para \\(n=1000\\) el tiempo de ejecuci√≥n incrementa en un orden. Las asignaciones son constantes"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#definici√≥n-y-prueba-del-algoritmo-1",
    "href": "VillegasJoseAlberto-U2-T1.html#definici√≥n-y-prueba-del-algoritmo-1",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Definici√≥n y prueba del algoritmo",
    "text": "Definici√≥n y prueba del algoritmo\nEn algebra lineal una de las aplicaciones del m√©todo de Gauss Jordan es su uso para encontrar la inversa de una matriz invertible \\(nxn\\), para lo cual el primer paso es agregar una matriz identidad a la derecha de la matriz inverible en forma de matriz aumentada y resolver el sistema por el m√©todo de Gauss Jordan. De acuerdo a Grossman & Flores (2012), el m√©todo para realizar Gauss-Jordan con pivoteo consiste en:\n\nEscribir el sistema en la forma de matriz aumentada. De la primer columna con componentes diferentes de cero (denominada columna pivote), seleccione la componente con el valor absoluto. Esta componente se denomina pivote:\nReacomodar los renglones para mover el pivote hasta arriba:\nDividir el primer rengl√≥n entre el pivote:\nSumar m√∫ltiplos del primer rengl√≥n a los otros renglones para hacer cero todas las componentes de la columna pivote:\nTapar el primer rengl√≥n y realice los pasos 1 al 4 en la submatriz que resulta:\nContinuar de esta manera hasta que la matriz est√© en la forma escalonada por renglones.\nResolver el sistema\n\nBajo este esquema se implementar√° el algoritmo."
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#definici√≥n-y-prueba-del-algoritmo-2",
    "href": "VillegasJoseAlberto-U2-T1.html#definici√≥n-y-prueba-del-algoritmo-2",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Definici√≥n y prueba del algoritmo",
    "text": "Definici√≥n y prueba del algoritmo\n\nusing LinearAlgebra \n\n# Crear una matriz aleatoria invertible de tama√±o n x n\nfunction generar_matriz_invertible(n)\n    while true\n        A = rand(n, n)  # Generamos una matriz aleatoria\n        if det(A) != 0   # Verificamos que sea invertible\n            return A\n        end\n    end\nend\n\nfunction gauss_jordan(A)\n    n = size(A, 1)  # Tama√±o de la matriz (nxn)\n    operaciones = 0  # Contador de operaciones\n\n    # Convertimos A en una matriz aumentada con la identidad (para calcular la inversa)\n    A = hcat(A, Matrix(I, n, n))  # Agregamos la matriz identidad a la derecha para expresarla en forma de matriz aumentada\n\n    # Eliminaci√≥n hacia adelante\n    for i in 1:n\n        # Pivoteo parcial (si es necesario)\n        max = argmax(abs.(A[i:n, i])) + (i - 1)  # Encuentra el m√°ximo en la columna\n        if max != i\n            A[i, :], A[max, :] = A[max, :], A[i, :]  # Intercambia filas\n            operaciones += n  # Contamos el intercambio de filas\n        end\n\n        # Normalizar el pivote a 1\n        pivote = A[i, i]\n        A[i, :] /= pivote\n        operaciones += n  # Divisi√≥n de toda la fila\n\n        # Eliminaci√≥n de los elementos debajo y arriba del pivote\n        for j in 1:n\n            if j != i  # Evitar la fila del pivote\n                factor = A[j, i]\n                A[j, :] -= factor * A[i, :]\n                operaciones += n  # Contamos la operaci√≥n de eliminaci√≥n\n            end\n        end\n    end\n\n    # La parte derecha de A ahora es la matriz inversa\n    return A[:, n+1:end], operaciones\nend\n\ngauss_jordan (generic function with 1 method)\n\n\nUna vez definidas las funciones podemos realizar una validaci√≥n simple para una matriz peque√±a de orden 3x3.\n\n# Prueba con una matriz 3x3\nn = 3\nA = generar_matriz_invertible(n)\n\n# Aplicamos Gauss-Jordan para encontrar la inversa\nA_inv, operaciones = gauss_jordan(A)\n\n# Mostrar resultados\nprintln(\"Matriz A:\")\nprintln(A)\nprintln(\"Matriz Inversa A^-1:\")\nprintln(A_inv)\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nMatriz A:\n[0.7176888293553598 0.1159503346927897 0.7824477172960047; 0.26816290254571196 0.5436422839447754 0.09663661895942965; 0.5776198687754796 0.502034634542894 0.6842905799728082]\nMatriz Inversa A^-1:\n[4.201278869398719 4.071118358154523 -5.378855536411074; -1.6582303726782912 0.5084526591919578 1.8242884828509491; -2.32978959049701 -3.809521529362638 4.663337360923403]\nN√∫mero de operaciones realizadas: 27\n\n\nSe corrobora que el algoritmo funciona correctamente. Tambi√©n desde este momento podemos observar que el n√∫mero de operaciones realizadas para \\(n=3\\) es de 27, es decir \\(3^3\\)"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n100-1",
    "href": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n100-1",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Evaluaci√≥n para \\(n=100\\)",
    "text": "Evaluaci√≥n para \\(n=100\\)\n\n# Experimento para n=100\nn = 100\nA = generar_matriz_invertible(n)\nA_inv, operaciones = gauss_jordan(A)\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nN√∫mero de operaciones realizadas: 1009600\n\n\nSe puede observar que el n√∫mero de operaciones realizadas cuando \\(n=100\\) es de apr√≥ximadamente 1,000,000 es decir \\(100^3\\)\n\nusing BenchmarkTools\n@btime gauss_jordan(A)\n\n  7.225 ms (80394 allocations: 63.79 MiB)\n\n\n([0.28970373469019167 -0.17420484581562626 ‚Ä¶ 0.27307472669636884 -0.3588290552142628; 0.11215087930590079 -0.25156162543991023 ‚Ä¶ 0.14969481586464503 -0.4030287746902638; ‚Ä¶ ; -0.0754963833616388 -0.10535739685169299 ‚Ä¶ 0.078313017746731 -0.22571431989707574; -0.04624036046053944 0.34960007812129645 ‚Ä¶ 0.02804706715744275 -0.30342600533361846], 1009600)"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n300-1",
    "href": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n300-1",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Evaluaci√≥n para \\(n=300\\)",
    "text": "Evaluaci√≥n para \\(n=300\\)\n\n# Experimento para n=300\nn = 300\nA = generar_matriz_invertible(n)\nA_inv, operaciones = gauss_jordan(A)\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nN√∫mero de operaciones realizadas: 27087900\n\n\nSe puede observar que el n√∫mero de operaciones realizadas cuando \\(n=300\\) es de apr√≥ximadamente 27,000,000 es decir \\(100^3\\)\n\nusing BenchmarkTools\n@btime gauss_jordan(A)\n\n  332.074 ms (1081266 allocations: 1.63 GiB)\n\n\n([0.2446861370288894 0.2603838908496686 ‚Ä¶ 0.9280233428073322 0.09375809661532152; 0.1298458317229163 0.12987395132258728 ‚Ä¶ 0.35016998210347056 0.01506863357009279; ‚Ä¶ ; 0.13790527314543724 0.35112067320686813 ‚Ä¶ 0.026894330076987827 -0.13166694676382443; 0.07039322841938805 -0.06504029318774748 ‚Ä¶ 0.5015589283627557 0.039208192096636965], 27087900)\n\n\nEl tiempo de ejecuci√≥n aumenta aproximadamente en dos √≥rdenes respecto a \\(n=100\\) lo mismo sucede para las asignaciones"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n1000-1",
    "href": "VillegasJoseAlberto-U2-T1.html#evaluaci√≥n-para-n1000-1",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Evaluaci√≥n para \\(n=1000\\)",
    "text": "Evaluaci√≥n para \\(n=1000\\)\n\n# Experimento para n=1000\nn = 1000\nA = generar_matriz_invertible(n)\nA_inv, operaciones = gauss_jordan(A)\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nN√∫mero de operaciones realizadas: 1000994000\n\n\nSe puede observar que el n√∫mero de operaciones realizadas cuando \\(n=1000\\) es de apr√≥ximadamente 1,000,000,000 es decir \\(1000^3\\)\n\nusing BenchmarkTools\n@btime gauss_jordan(A)\n\n  30.021 s (12005472 allocations: 59.87 GiB)\n\n\n([0.047490859301975295 -0.060854470450899374 ‚Ä¶ -0.12558169672686376 0.1434304526853882; -0.1200956782253656 -0.428885355426993 ‚Ä¶ -0.013085833224851684 0.30326859892872826; ‚Ä¶ ; 1.7067673603290574 1.0086591100969922 ‚Ä¶ -0.831195709124633 -0.3635885587092932; 1.237672201837348 0.8858751875164227 ‚Ä¶ -0.7664065225726228 -0.16137824678541648], 1000994000)\n\n\nEl tiempo de ejecuci√≥n aumenta aproximadamente en dos √≥rdenes respecto a \\(n=300\\) las asignaciones incrementan en un orden"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#experimento-para-matrices-dispersas-1",
    "href": "VillegasJoseAlberto-U2-T1.html#experimento-para-matrices-dispersas-1",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "Experimento para matrices dispersas",
    "text": "Experimento para matrices dispersas\nBajor la misma l√≥gica que se evalu√≥ este algoritmo se generar√° una matriz dispersa tama√±o \\(nxn\\) que sea invertible.\n\nusing SparseArrays, LinearAlgebra\n\nfunction generar_matriz_invertible_dispersada(n::Int, densidad::Float64)\n    # Primero generamos una matriz dispersa aleatoria de tama√±o n x n\n    A = sprandn(n, n, 0.01)\n\n    # Hacemos la matriz sim√©trica A = A + A^T para asegurar que sea sim√©trica\n    A = A + transpose(A)\n\n    # A√±adimos una constante al diagonal para asegurar que sea positiva definida\n    # Esto ayuda a evitar que tenga autovalores no positivos\n    for i in 1:n\n        A[i,i] += n  # Incrementamos la diagonal para garantizar la positividad\n    end\n\n    # A es ahora sim√©trica y positiva definida, y como es dispersa, deber√≠a ser invertible\n    return A\nend\n\ngenerar_matriz_invertible_dispersada (generic function with 1 method)\n\n\n\n# Experimento para n=1000\nn = 1000\nA = generar_matriz_invertible(n)\nA_inv, operaciones = gauss_jordan(A)\nprintln(\"N√∫mero de operaciones realizadas: $operaciones\")\n\nN√∫mero de operaciones realizadas: 1000987000\n\n\nObservarmos que el n√∫mero de operaciones continua siendo aproximadamente \\(n^3\\)\n\nusing BenchmarkTools\n@btime gauss_jordan(A)\n\n  31.942 s (12005430 allocations: 59.87 GiB)\n\n\n([-0.286088270150775 -0.04415745714555952 ‚Ä¶ -0.02341198529697472 -0.060345876344513556; -0.6395347509959397 0.20227489477122187 ‚Ä¶ 0.015799245413789784 -0.0076372936972852745; ‚Ä¶ ; -0.10946769430792393 0.008548864678396426 ‚Ä¶ -0.007695531472638406 -0.08864286022847348; -0.21194227741102356 0.08071600512590583 ‚Ä¶ 0.009539117934955094 -0.04134071560159264], 1000987000)\n\n\nNo se not√≥ una diferencia significativa en tiempo de ejecuci√≥n ni en asignaciones"
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#cu√°l-es-el-impacto-de-acceder-los-elementos-contiguos-en-memoria-de-una-matriz",
    "href": "VillegasJoseAlberto-U2-T1.html#cu√°l-es-el-impacto-de-acceder-los-elementos-contiguos-en-memoria-de-una-matriz",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "¬øCu√°l es el impacto de acceder los elementos contiguos en memoria de una matriz?",
    "text": "¬øCu√°l es el impacto de acceder los elementos contiguos en memoria de una matriz?\nEl acceso a los elementos contiguos en memoria de una matriz podr√≠a tener un impacto significativo en los tiempos de ejecuci√≥n de los algoritmos.Cuando accedes a elementos contiguos en memoria (por ejemplo, en un orden fila-por-fila o columna-por-columna), se puede aprovechar la memoria cach√©, para acceder a estos y que no tengan que ser cargados desde la memoria principal, que es m√°s lenta."
  },
  {
    "objectID": "VillegasJoseAlberto-U2-T1.html#qu√©-cambiar√≠as-si-utilizas-matrices-dispersas-cu√°les-ser√≠an-los-costos",
    "href": "VillegasJoseAlberto-U2-T1.html#qu√©-cambiar√≠as-si-utilizas-matrices-dispersas-cu√°les-ser√≠an-los-costos",
    "title": "2A. Reporte escrito. Experimentos y an√°lisis de estructuras de datos.",
    "section": "¬øQu√© cambiar√≠as si utilizas matrices dispersas? ¬øCu√°les ser√≠an los costos?",
    "text": "¬øQu√© cambiar√≠as si utilizas matrices dispersas? ¬øCu√°les ser√≠an los costos?\nComo se pudo corroborar en los experimentos el uso de matrices dispersas se comport√≥ distinto para cada algoritmo, para el de multiplicaci√≥n increment√≥ los tiempos de ejecuci√≥n, mientras que para el de eliminaci√≥n gaussiana no tuvo diferencias considerables para \\(n=1000\\)"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An√°lisis de Algoritmos 2025",
    "section": "",
    "text": "Bienvenido/a. Este sitio contiene un Compendio de reportes de reportes escritos para la clase de An√°lisis de Algoritmos de la Maestr√≠a en Ciencia de Datos INFOTEC\n\n\n\nUnidad 1: Experimentos y an√°lisis\nUnidad 2: Estructuras de datos\nUnidad 3: Algoritmos de ordenamiento\nUnidad 4: Algoritmos de b√∫squeda\nUnidad 5: Intersecci√≥n de conjuntos"
  },
  {
    "objectID": "VillegasJoseAlbertoU1T1.html",
    "href": "VillegasJoseAlbertoU1T1.html",
    "title": "1A. Reporte escrito. Experimentos y an√°lisis.",
    "section": "",
    "text": "Jos√© Alberto Villegas D√≠az Disciplina"
  },
  {
    "objectID": "VillegasJoseAlbertoU1T1.html#tabla-1.crecimiento-de-funciones-de-complejidad-para-diferentes-tama√±os-de-entrada-n",
    "href": "VillegasJoseAlbertoU1T1.html#tabla-1.crecimiento-de-funciones-de-complejidad-para-diferentes-tama√±os-de-entrada-n",
    "title": "1A. Reporte escrito. Experimentos y an√°lisis.",
    "section": "Tabla 1.Crecimiento de Funciones de Complejidad para Diferentes Tama√±os de Entrada \\(n\\)",
    "text": "Tabla 1.Crecimiento de Funciones de Complejidad para Diferentes Tama√±os de Entrada \\(n\\)\n\\[\n\\begin{array}{|c|c|c|c|c|}\n\\hline\n\\textbf{Funci√≥n} & n=100 & n=1000 & n=10000 & n=100000 \\\\\n\\hline\nO(1) & 1 & 1 & 1 & 1 \\\\\nO(\\log n) & 6 & 9 & 13 & 16 \\\\\nO(n) & 100 & 10^3 & 10^4 & 10^5 \\\\\nO(n \\log n) & 6 \\times 10^2 & 9 \\times 10^3 & 1.3 \\times 10^5 & 1.6 \\times 10^6 \\\\\nO(n^2) & 10^3 & 10^6 & 10^8 & 10^{10} \\\\\nO(n^3) & 10^6 & 10^9 & 10^{12} & 10^{15} \\\\\nO(n!) & \\infty & \\infty & \\infty & \\infty \\\\\nO(n^n) & \\infty & \\infty & \\infty & \\infty \\\\\n\\hline\n\\end{array}\n\\]\nValores aproximados del crecimiento temporal para distintas funciones de complejidad en funci√≥n del tama√±o de la entrada ( n ). Se muestra c√≥mo aumentan los costos computacionales desde complejidades constantes hasta exponenciales y factoriales, utilizando notaci√≥n cient√≠fica para facilitar la comparaci√≥n en rangos grandes de ( n )."
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html",
    "href": "VillegasJoseAlbertoU4-T1.html",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "",
    "text": "Jos√© Alberto Villegas D√≠az Disciplina"
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#introducci√≥n",
    "href": "VillegasJoseAlbertoU4-T1.html#introducci√≥n",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "Introducci√≥n",
    "text": "Introducci√≥n\nKnuth (1998) se√±ala que el problema de b√∫squeda consiste en encontrar datos almacenados a partir de una identificaci√≥n √∫nica, conocida como clave. Dado un conjunto de \\(N\\) registros, el objetivo es localizar aquel que contiene la clave proporcionada.\nEn este reporte, se implementan y comparan cinco algoritmos de b√∫squeda por comparaci√≥n:\n\nB√∫squeda binaria acotada: Un m√©todo eficiente para buscar en arreglos ordenados, con complejidad \\(O(\\log n)\\).\n\nB√∫squeda secuencial B0 (b√∫squeda unaria): Una b√∫squeda lineal simple que examina cada elemento secuencialmente hasta encontrar el objetivo, con complejidad en el peor caso \\(O(n)\\).\n\nB√∫squeda no acotada B1 (doubling search/galloping): Una t√©cnica que combina b√∫squeda lineal con saltos exponenciales para localizar un intervalo antes de aplicar b√∫squeda binaria, √∫til cuando el tama√±o del conjunto de datos es desconocido.\n\nB√∫squeda no acotada B2 (doubling-doubling search): Una variante m√°s agresiva de la b√∫squeda B1, que incrementa el tama√±o de los saltos de manera m√°s r√°pida para reducir el n√∫mero de comparaciones.\n\nB√∫squeda mediante SkipList: Una estructura de datos probabil√≠stica que permite b√∫squedas eficientes con complejidad esperada \\(O(\\log n)\\).\n\nEl objetivo de este estudio es analizar el rendimiento de estos algoritmos bajo diferentes condiciones, evaluando su eficiencia en t√©rminos de tiempo de ejecuci√≥n y n√∫mero de comparaciones realizadas. A trav√©s de experimentos controlados, se busca determinar en qu√© escenarios cada algoritmo ofrece el mejor desempe√±o, considerando tanto entornos acotados (donde el tama√±o del conjunto de datos es conocido) como no acotados (donde el tama√±o es din√°mico o desconocido).\nLos resultados obtenidos proporcionar√°n insights valiosos sobre las ventajas y desventajas de cada m√©todo, permitiendo una selecci√≥n informada del algoritmo m√°s adecuado seg√∫n los requisitos espec√≠ficos de una aplicaci√≥n dada."
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#ordenamiento-previo",
    "href": "VillegasJoseAlbertoU4-T1.html#ordenamiento-previo",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "Ordenamiento previo",
    "text": "Ordenamiento previo\nPara el correcto funcionamiento de los algoritmos de b√∫squeda, es necesario que las listas de posteo d√≥nde realizaremos dichas b√∫squedas est√©n ordenadas. Por lo que se utilizar√° el algoritmo de ordenamiento ‚Äúheapsort‚Äù mismo que demostr√≥ una mayor eficiencia para el ordenamiento de estas listas de posteo en el ‚ÄúReporte 3.A Experimentos y an√°lisis de algoritmos de ordenamiento‚Äù.\n\nusing JSON\nusing Dates\n\n# Funci√≥n para ajustar el mont√≠culo (heapify) - √çndices basados en 1\nfunction heapify!(arr, n, i)\n    largest = i\n    left = 2 * i      # Hijo izquierdo (ajustado para base 1)\n    right = 2 * i + 1 # Hijo derecho (ajustado para base 1)\n\n    # Comparar con el hijo izquierdo\n    if left &lt;= n && arr[left] &gt; arr[largest]\n        largest = left\n    end\n\n    # Comparar con el hijo derecho\n    if right &lt;= n && arr[right] &gt; arr[largest]\n        largest = right\n    end\n\n    # Si el mayor no es la ra√≠z, intercambiar y seguir ajustando\n    if largest != i\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify!(arr, n, largest)\n    end\nend\n\n# Implementaci√≥n de HeapSort - √çndices basados en 1\nfunction heapsort!(arr)\n    n = length(arr)\n\n    # Construir el max-heap\n    for i in n √∑ 2:-1:1\n        heapify!(arr, n, i)\n    end\n\n    # Extraer elementos del heap uno por uno\n    for i in n:-1:2\n        arr[1], arr[i] = arr[i], arr[1]  # Mover la ra√≠z al final\n        heapify!(arr, i - 1, 1)\n    end\n\n    return arr\nend\n\n# Funci√≥n para cargar y ordenar el archivo JSON\nfunction ordenar_json(p::String)\n    # Construir la ruta del archivo\n    ruta_archivo = joinpath(homedir(), raw\"C:\\Users\\josea\\Downloads\\listas-posteo-con-perturbaciones\", \n                           \"listas-posteo-con-perturbaciones-p=\" * p * \".json\")\n\n    # Cargar el archivo JSON\n    datos = JSON.parsefile(ruta_archivo)\n    \n    # Ordenar cada lista en el archivo JSON\n    for (clave, arr) in datos\n        heapsort!(arr)\n    end\n    \n    # Devolver los datos ordenados\n    return datos\nend\n\nordenar_json (generic function with 1 method)\n\n\n\n# Como son las mismas listas con diferentes niveles de desorden basta con que tomemos un archivo (el de menor perturbaci√≥n)\nlista = ordenar_json(\"016\")\n\nDict{String, Any} with 100 entries:\n  \"reunion\"      =&gt; Any[260, 275, 294, 296, 314, 317, 341, 384, 457, 529  ‚Ä¶  49‚Ä¶\n  \"virtual\"      =&gt; Any[45, 47, 63, 97, 255, 291, 295, 310, 327, 370  ‚Ä¶  49582,‚Ä¶\n  \"julio\"        =&gt; Any[25, 31, 74, 260, 297, 341, 361, 404, 434, 443  ‚Ä¶  47540‚Ä¶\n  \"votos\"        =&gt; Any[66, 86, 102, 311, 330, 334, 462, 560, 637, 655  ‚Ä¶  4483‚Ä¶\n  \"propuesta\"    =&gt; Any[37, 3109, 3637, 3676, 4013, 4015, 4021, 4027, 4046, 404‚Ä¶\n  \"nacional\"     =&gt; Any[260, 262, 267, 269, 272, 273, 281, 282, 289, 294  ‚Ä¶  49‚Ä¶\n  \"electoral\"    =&gt; Any[65, 132, 170, 190, 208, 310, 578, 591, 701, 745  ‚Ä¶  472‚Ä¶\n  \"@m_ebrard\"    =&gt; Any[351, 359, 366, 623, 1745, 1983, 2838, 2923, 3360, 3538 ‚Ä¶\n  \"jovenes\"      =&gt; Any[22, 191, 192, 195, 196, 213, 220, 245, 350, 365  ‚Ä¶  486‚Ä¶\n  \"_num\"         =&gt; Any[25, 31, 32, 37, 52, 62, 66, 74, 91, 92  ‚Ä¶  49972, 49974‚Ä¶\n  \"aqui\"         =&gt; Any[19, 52, 92, 299, 315, 504, 598, 659, 678, 776  ‚Ä¶  49079‚Ä¶\n  \"mayor\"        =&gt; Any[54, 290, 423, 701, 887, 1107, 1148, 1379, 1617, 1719  ‚Ä¶‚Ä¶\n  \"#envivo\"      =&gt; Any[11, 15, 19, 24, 39, 58, 59, 63, 73, 81  ‚Ä¶  49613, 49618‚Ä¶\n  \"üëâ\"           =&gt; Any[30, 31, 87, 295, 365, 504, 557, 600, 838, 964  ‚Ä¶  49442‚Ä¶\n  \"mexico\"       =&gt; Any[10, 13, 14, 15, 21, 25, 27, 30, 36, 40  ‚Ä¶  49806, 49835‚Ä¶\n  \"@epn\"         =&gt; Any[3, 12, 46, 224, 260, 262, 269, 272, 273, 281  ‚Ä¶  49862,‚Ä¶\n  \"poder\"        =&gt; Any[37, 314, 374, 671, 767, 817, 888, 908, 943, 984  ‚Ä¶  488‚Ä¶\n  \"pri\"          =&gt; Any[52, 92, 168, 233, 564, 627, 657, 671, 692, 698  ‚Ä¶  4887‚Ä¶\n  \"encuentro\"    =&gt; Any[716, 1036, 1060, 1209, 1256, 3285, 3573, 3632, 3716, 37‚Ä¶\n  \"pena\"         =&gt; Any[12, 26, 66, 98, 102, 265, 270, 275, 285, 294  ‚Ä¶  49904,‚Ä¶\n  \"gano\"         =&gt; Any[49, 153, 183, 304, 369, 490, 527, 584, 597, 602  ‚Ä¶  470‚Ä¶\n  \"reune\"        =&gt; Any[3173, 3208, 3628, 3913, 4478, 4502, 4662, 4673, 4699, 4‚Ä¶\n  \"plan\"         =&gt; Any[202, 1209, 1351, 3109, 3730, 3863, 4218, 4259, 4261, 43‚Ä¶\n  \"presidencial\" =&gt; Any[12, 16, 47, 63, 132, 145, 242, 259, 317, 450  ‚Ä¶  48944,‚Ä¶\n  \"resultados\"   =&gt; Any[1, 31, 49, 50, 153, 162, 237, 241, 242, 251  ‚Ä¶  45776, ‚Ä¶\n  ‚ãÆ              =&gt; ‚ãÆ\n\n\n\n# Cargar listas de consultas\nconsultas1 = JSON.parsefile(joinpath(homedir(), raw\"C:\\Users\\josea\\Downloads\\consultas-1-listas-posteo.json\"))\nconsultas2 = JSON.parsefile(joinpath(homedir(), raw\"C:\\Users\\josea\\Downloads\\consultas-2-listas-posteo.json\"))\nconsultas3 = JSON.parsefile(joinpath(homedir(), raw\"C:\\Users\\josea\\Downloads\\consultas-3-listas-posteo.json\"))\nconsultas4 = JSON.parsefile(joinpath(homedir(), raw\"C:\\Users\\josea\\Downloads\\consultas-4-listas-posteo.json\"))\n\n10000-element Vector{Any}:\n 39835\n 37103\n 20584\n 11036\n  3086\n 26699\n  9561\n 36445\n  2853\n 27873\n  2216\n  1500\n 48987\n     ‚ãÆ\n  4218\n 23841\n 38354\n 40129\n 20626\n 32118\n 42722\n 20874\n 47462\n 37764\n 29520\n 10134\n\n\n\n#Inspeccionamos de manera general las caracter√≠sticas de las listas de consulta. \nprintln(length(consultas1))\nprintln(length(consultas2))\nprintln(length(consultas3))\nprintln(length(consultas4))\n\n10000\n10000\n10000\n10000\n\n\n\nprintln(consultas1[1:20])\nprintln(consultas2[1:10])\nprintln(consultas3[1:10])\nprintln(consultas4[1:10])\n\nAny[5, 12, 3, 2, 4, 3, 15, 1, 4, 14, 5, 3, 14, 9, 3, 4, 1, 12, 13, 5]\nAny[200, 229, 46, 186, 58, 183, 208, 212, 162, 72]\nAny[694, 555, 2078, 3674, 667, 1144, 2329, 1163, 3398, 3291]\nAny[39835, 37103, 20584, 11036, 3086, 26699, 9561, 36445, 2853, 27873]\n\n\nDe lo anterior podemos darnos cuenta que las listas de consulta constan del mismo n√∫mero de elementos, con la particularidad que los elementos de las listas aumentan en uno o dos √≥rdenes de magnitud consecutivamente. De tal manera que la primera lista contiene elementos de orden de \\(10^0\\) a \\(10^1\\) y la √∫ltima elementos de \\(10^3\\) y \\(10^4\\)"
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-binaria-acotada",
    "href": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-binaria-acotada",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "B√∫squeda binaria acotada",
    "text": "B√∫squeda binaria acotada\nDe acuerdo con Knuth (1998), la b√∫squeda binaria es un algoritmo eficiente para encontrar un elemento en una lista ordenada. Funciona comparando el valor buscado \\(K\\) con el elemento central de la lista:\n\nSi \\(K\\) es igual al valor medio, la b√∫squeda finaliza con √©xito.\n\nSi \\(K\\) es menor, se repite la b√∫squeda en la mitad inferior de la lista.\n\nSi \\(K\\) es mayor, se repite en la mitad superior.\n\nEste proceso se repite hasta encontrar el elemento o determinar que no est√° en la lista.\nAlgoritmo\nDada una lista ordenada con claves \\(K_1, K_2, \\dots, K_N\\), el algoritmo se describe as√≠:\n\nInicializaci√≥n: Definir los l√≠mites \\(l = 1\\) y \\(u = N\\).\n\nBucle: Mientras \\(l \\leq u\\):\n\nCalcular el punto medio: \\(i = \\lfloor (l + u)/2 \\rfloor\\).\n\nSi \\(K = K_i\\), retornar √©xito.\n\nSi \\(K &lt; K_i\\), actualizar \\(u = i - 1\\).\n\nSi \\(K &gt; K_i\\), actualizar \\(l = i + 1\\).\n\n\nSi el bucle termina sin √©xito, el elemento no est√° en la lista.\n\nComplejidad $ O(n) $\n\nusing JSON\n\nfunction busqueda_binaria_acotada(arr, valor, bajo, alto, contador)\n    while bajo &lt;= alto\n        medio = (bajo + alto) √∑ 2\n        contador[] += 1  # Incrementar contador de comparaciones\n        \n        if arr[medio] == valor\n            return medio  # Valor encontrado\n        elseif arr[medio] &lt; valor\n            bajo = medio + 1\n        else\n            alto = medio - 1\n        end\n    end\n    return -1  # Valor no encontrado\nend\n\nfunction buscar_en_listas_ordenadas(datos_ordenados, elementos_a_buscar)\n    # Contador de comparaciones (usamos un Ref para poder modificarlo en las funciones)\n    total_comparaciones = Ref(0)\n    \n    # Diccionario para guardar resultados por clave\n    resultados = Dict{String, Dict}()\n    \n    for (clave, arr) in datos_ordenados\n        resultados_clave = Dict{Any, Any}()\n        comparaciones_clave = 0\n        \n        for elemento in elementos_a_buscar\n            # Realizar b√∫squeda binaria acotada\n            posicion = busqueda_binaria_acotada(arr, elemento, 1, length(arr), total_comparaciones)\n            resultados_clave[elemento] = posicion != -1 ? \"Encontrado en posici√≥n $posicion\" : \"No encontrado\"\n        end\n        \n        resultados[clave] = resultados_clave\n    end\n    \n    # Devolver resultados y total de comparaciones\n    return resultados, total_comparaciones[]\nend\n\n# Funci√≥n completa para cargar, ordenar y buscar\nfunction procesar_archivo_y_buscar(datos_ordenados, elementos_a_buscar)\n    \n    # Realizar b√∫squedas en las listas ordenadas del diccionario\n    \n    resultados, total_comparaciones = buscar_en_listas_ordenadas(datos_ordenados, elementos_a_buscar)\n    \n    println(\"Total de comparaciones realizadas: $total_comparaciones\")\n    return resultados\nend\n\nprocesar_archivo_y_buscar (generic function with 1 method)\n\n\n\nusing JSON\n\nfunction busqueda_binaria_acotada(arr, valor, bajo, alto, contador)\n    while bajo &lt;= alto\n        medio = (bajo + alto) √∑ 2\n        contador[] += 1  # Incrementar contador de comparaciones\n        \n        if arr[medio] == valor\n            return medio  # Valor encontrado\n        elseif arr[medio] &lt; valor\n            bajo = medio + 1\n        else\n            alto = medio - 1\n        end\n    end\n    return -1  # Valor no encontrado\nend\n\nfunction buscar_en_listas_ordenadas(datos_ordenados, elementos_a_buscar)\n    # Contador de comparaciones (usamos un Ref para poder modificarlo en las funciones)\n    total_comparaciones = Ref(0)\n    \n    # Diccionario para guardar resultados por clave\n    resultados = Dict{String, Dict}()\n    \n    for (clave, arr) in datos_ordenados\n        resultados_clave = Dict{Any, Any}()\n        comparaciones_clave = 0\n        \n        for elemento in elementos_a_buscar\n            # Realizar b√∫squeda binaria acotada\n            posicion = busqueda_binaria_acotada(arr, elemento, 1, length(arr), total_comparaciones)\n            resultados_clave[elemento] = posicion != -1 ? \"Encontrado en posici√≥n $posicion\" : \"No encontrado\"\n        end\n        \n        resultados[clave] = resultados_clave\n    end\n    \n    # Devolver resultados y total de comparaciones\n    return resultados, total_comparaciones[]\nend\n\n# Funci√≥n completa para cargar, ordenar y buscar\nfunction procesar_archivo_y_buscar(datos_ordenados, elementos_a_buscar)\n    \n    # Realizar b√∫squedas en las listas ordenadas del diccionario\n    \n    resultados, total_comparaciones = buscar_en_listas_ordenadas(datos_ordenados, elementos_a_buscar)\n    \n    println(\"Total de comparaciones realizadas: $total_comparaciones\")\n    return resultados\nend\n\nprocesar_archivo_y_buscar (generic function with 1 method)\n\n\n\n@time begin\n    procesar_archivo_y_buscar(lista,(consultas1))\nend\n@time begin\n    procesar_archivo_y_buscar(lista,(consultas2))\nend\n@time begin\n    procesar_archivo_y_buscar(lista,(consultas3))\nend\n@time begin\n    procesar_archivo_y_buscar(lista,(consultas4))\nend\n\nTotal de comparaciones realizadas: 9658445\n  0.857163 seconds (1.27 M allocations: 26.252 MiB, 19.35% gc time, 9.43% compilation time)\nTotal de comparaciones realizadas: 9810026\n  0.635125 seconds (1.25 M allocations: 26.321 MiB, 1.37% gc time, 0.50% compilation time)\nTotal de comparaciones realizadas: 9999849\n  1.125757 seconds (20.15 M allocations: 352.905 MiB, 20.68% gc time)\nTotal de comparaciones realizadas: 10052264\n  1.054306 seconds (22.81 M allocations: 393.393 MiB, 13.41% gc time)\n\n\nDict{String, Dict} with 100 entries:\n  \"reunion\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"virtual\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"julio\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"votos\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"propuesta\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"nacional\"     =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"electoral\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"@m_ebrard\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"jovenes\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"_num\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 4212\", 4700=&gt;‚Ä¶\n  \"aqui\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"mayor\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"#envivo\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"üëâ\"           =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"mexico\"       =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"@epn\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"poder\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"pri\"          =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"encuentro\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"pena\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"gano\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"reune\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"plan\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"presidencial\" =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"resultados\"   =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  ‚ãÆ              =&gt; ‚ãÆ\n\n\nDe lo anterior podemos observar el n√∫mero de comparaciones y los tiempos de ejecuci√≥n permanecieron relativamente constantes, con una variaci√≥n m√≠nima. Esto es de esperarse ya que el algortimo de b√∫squeda binaria tine una complejidad de \\(O(\\log n)\\). Sin embargo, s√≠ se observa un incremento considerable n√∫mero de asignaciones, esto se puede atribuir al tama√±o de los n√∫meros que integran las listas de consulta."
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-secuencial-o-lineal-b_0",
    "href": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-secuencial-o-lineal-b_0",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "B√∫squeda secuencial o lineal \\(B_0\\)",
    "text": "B√∫squeda secuencial o lineal \\(B_0\\)\nDe acuerdo con Knuth (1998) Dada una tabla de registros \\(R_1, R_2, \\dots, R_N\\), cuyas claves respectivas son \\(K_1, K_2, \\dots, K_N\\), este algoritmo busca un argumento dado \\(K\\). Suponemos que \\(N \\geq 1\\).\n\n[Inicializaci√≥n.] Establecer \\(i \\gets 1\\).\n[Comparaci√≥n.] Si \\(K = K_i\\), el algoritmo termina con √©xito.\n[Avance.] Aumentar \\(i\\) en 1.\n[¬øFin de archivo?] Si \\(i \\leq N\\), regresar al paso 2. De lo contrario, el algoritmo termina sin √©xito.\n\nLa complejidad de este algoritmo en el peor caso es \\(O(n)\\)\n\nfunction busqueda_lineal(arr, valor, contador)\n    for (i, elemento) in enumerate(arr)\n        contador[] += 1  # Incrementar contador de comparaciones\n        if elemento &gt;= valor\n            return i  # Devuelve la posici√≥n de inserci√≥n\n        end\n    end\n    return length(arr) + 1  # Insertar al final si todos los elementos son menores\nend\n\n\nfunction buscar_lineal_en_listas(datos_ordenados, elementos_a_buscar)\n    # Contador de comparaciones (usamos un Ref para poder modificarlo en las funciones)\n    total_comparaciones = Ref(0)\n    \n    # Diccionario para guardar resultados por clave\n    resultados = Dict{String, Dict}()\n    \n    for (clave, arr) in datos_ordenados\n        resultados_clave = Dict{Any, Any}()\n        comparaciones_clave = 0\n        \n        for elemento in elementos_a_buscar\n            # Realizar b√∫squeda lineal\n            posicion = busqueda_lineal(arr, elemento, total_comparaciones)\n            resultados_clave[elemento] = posicion != -1 ? \"Encontrado en posici√≥n $posicion\" : \"No encontrado\"\n        end\n        \n        resultados[clave] = resultados_clave\n    end\n    \n    # Devolver resultados y total de comparaciones\n    return resultados, total_comparaciones[]\nend\n\n# Funci√≥n completa para cargar y buscar \nfunction procesar_archivo_y_buscar_lineal(datos_ordenados, elementos_a_buscar)\n\n    #Realizar b√∫squedas lineales en las listas\n    resultados, total_comparaciones = buscar_lineal_en_listas(datos_ordenados, elementos_a_buscar)\n    \n    println(\"Total de comparaciones realizadas (lineal): $total_comparaciones\")\n    return resultados\nend\n\nprocesar_archivo_y_buscar_lineal (generic function with 1 method)\n\n\n\n@time begin \n    procesar_archivo_y_buscar_lineal(lista,consultas1)\nend\n@time begin \n    procesar_archivo_y_buscar_lineal(lista,consultas2)\nend\n@time begin \n    procesar_archivo_y_buscar_lineal(lista,consultas3)\nend\n@time begin \n    procesar_archivo_y_buscar_lineal(lista,consultas4)\nend\n\nTotal de comparaciones realizadas (lineal): 1285284\n  1.085884 seconds (5.08 M allocations: 194.840 MiB, 49.78% gc time, 60.72% compilation time)\nTotal de comparaciones realizadas (lineal): 6025401\n  0.574643 seconds (5.04 M allocations: 193.952 MiB, 6.19% gc time, 0.51% compilation time)\nTotal de comparaciones realizadas (lineal): 76747269\n  3.351496 seconds (81.82 M allocations: 1.371 GiB, 14.31% gc time)\nTotal de comparaciones realizadas (lineal): 989149917\n 45.471095 seconds (996.18 M allocations: 14.996 GiB, 6.26% gc time)\n\n\nDict{String, Dict} with 100 entries:\n  \"reunion\"      =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 1712\", 4700=&gt;‚Ä¶\n  \"virtual\"      =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 712\", 4700=&gt;\"‚Ä¶\n  \"julio\"        =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 439\", 4700=&gt;\"‚Ä¶\n  \"votos\"        =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 752\", 4700=&gt;\"‚Ä¶\n  \"propuesta\"    =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 286\", 4700=&gt;\"‚Ä¶\n  \"nacional\"     =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 1530\", 4700=&gt;‚Ä¶\n  \"electoral\"    =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 670\", 4700=&gt;\"‚Ä¶\n  \"@m_ebrard\"    =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 309\", 4700=&gt;\"‚Ä¶\n  \"jovenes\"      =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 424\", 4700=&gt;\"‚Ä¶\n  \"_num\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 4212\", 4700=&gt;‚Ä¶\n  \"aqui\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 440\", 4700=&gt;\"‚Ä¶\n  \"mayor\"        =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 323\", 4700=&gt;\"‚Ä¶\n  \"#envivo\"      =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 606\", 4700=&gt;\"‚Ä¶\n  \"üëâ\"           =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 345\", 4700=&gt;\"‚Ä¶\n  \"mexico\"       =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 2852\", 4700=&gt;‚Ä¶\n  \"@epn\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 2158\", 4700=&gt;‚Ä¶\n  \"poder\"        =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 434\", 4700=&gt;\"‚Ä¶\n  \"pri\"          =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 532\", 4700=&gt;\"‚Ä¶\n  \"encuentro\"    =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 647\", 4700=&gt;\"‚Ä¶\n  \"pena\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 2500\", 4700=&gt;‚Ä¶\n  \"gano\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 495\", 4700=&gt;\"‚Ä¶\n  \"reune\"        =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 388\", 4700=&gt;\"‚Ä¶\n  \"plan\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 358\", 4700=&gt;\"‚Ä¶\n  \"presidencial\" =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 680\", 4700=&gt;\"‚Ä¶\n  \"resultados\"   =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 469\", 4700=&gt;\"‚Ä¶\n  ‚ãÆ              =&gt; ‚ãÆ\n\n\nPodemos observar que los tiempos de ejecuciones y n√∫mero de comparaciones de este algoritmo aumentaron de manera significativa respecto al de b√∫squeda binaria, esto es porque la complejidad depende de la posici√≥n del valor buscado y de si se encuentra o no, siendo el peor caso \\(O(n)\\). Podemos observar que muchos de los valores que busc√≥ no fueron encontrados para lo que el algoritmo compar√≥ el valor buscado con todos los elementos de la lista antes de concluir que no est√° presente, es decir se comport√≥ m√∫ltiples veces como el peor caso. Esto explica el aumento en varios √≥rdenes en tiempos de ejecuci√≥n y comparaciones."
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-no-acotada-b_1",
    "href": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-no-acotada-b_1",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "B√∫squeda no acotada \\(B_1\\)",
    "text": "B√∫squeda no acotada \\(B_1\\)\nBaeza-Yates y Salinger (2010) mencionan que el algoritmo de b√∫squeda exponencial, que se utiliza para localizar un elemento en un conjunto ordenado de manera eficiente consiste en dos fases:\nFase 1: El proceso comienza seleccionando un elemento y busc√°ndolo en otro conjunto mediante saltos exponenciales (1, 2, 4, ‚Ä¶). hasta que el salto supera la posici√≥n del elemento buscado.\nFase 2: Se realiza b√∫squeda binaria en el rango detectado. Esta estrategia, conocida como b√∫squeda galopante, imita la b√∫squeda binaria en secuencias no acotadas y mantiene una complejidad de \\(O(\\log p)\\) donde \\(p\\) es la posici√≥n de inserci√≥n.\n\nusing JSON\n\nfunction busqueda_doubling(arr, valor, contador)\n    n = length(arr)\n    \n\n    # Fase 1: B√∫squeda exponencial para encontrar el rango\n    if arr[1] == valor\n        contador[] += 1\n        return 1\n    end\n    \n    indice = 2  # Comenzamos desde el segundo elemento (√≠ndice 1 ya verificado)\n    while indice &lt;= n && arr[indice] &lt; valor\n        contador[] += 1  # Comparaci√≥n arr[indice] &lt; valor\n        indice *= 2\n    end\n    \n    # Ajustar los l√≠mites para la b√∫squeda binaria\n    bajo = indice √∑ 2\n    alto = min(indice, n)\n    \n    # Fase 2: B√∫squeda binaria dentro del rango encontrado\n    while bajo &lt;= alto\n        medio = (bajo + alto) √∑ 2\n        contador[] += 1  # Comparaci√≥n arr[medio] == valor\n        \n        if arr[medio] == valor\n            return medio\n        elseif arr[medio] &lt; valor\n            bajo = medio + 1\n        else\n            alto = medio - 1\n        end\n    end\n    \n    return -1  # Elemento no encontrado\nend\n\nfunction buscar_con_doubling(datos_ordenados, elementos_a_buscar)\n    # Contador de comparaciones\n    total_comparaciones = Ref(0)\n    \n    # Diccionario para resultados\n    resultados = Dict{String, Dict}()\n    \n    for (clave, arr) in datos_ordenados\n        resultados_clave = Dict{Any, Any}()\n        \n        for elemento in elementos_a_buscar\n            posicion = busqueda_doubling(arr, elemento, total_comparaciones)\n            resultados_clave[elemento] = posicion != -1 ? \"Encontrado en posici√≥n $posicion\" : \"No encontrado\"\n        end\n        \n        resultados[clave] = resultados_clave\n    end\n    \n    return resultados, total_comparaciones[]\nend\n\nfunction procesar_archivo_y_buscar_doubling(datos_ordenados, elementos_a_buscar)\n    \n    #Realizar b√∫squedas con doubling search\n    resultados, total_comparaciones = buscar_con_doubling(datos_ordenados, elementos_a_buscar)\n    \n    println(\"Total de comparaciones realizadas (doubling search): $total_comparaciones\")\n    return resultados\nend\n\nprocesar_archivo_y_buscar_doubling (generic function with 1 method)\n\n\n\n@time begin \n    procesar_archivo_y_buscar_doubling(lista,consultas1)\nend\n@time begin \n    procesar_archivo_y_buscar_doubling(lista,consultas2)\nend\n@time begin \n    procesar_archivo_y_buscar_doubling(lista,consultas3)\nend\n@time begin \n    procesar_archivo_y_buscar_doubling(lista,consultas4)\nend\n\nTotal de comparaciones realizadas (doubling search): 1228088\n  0.480016 seconds (257.94 k allocations: 10.365 MiB, 34.07% compilation time)\nTotal de comparaciones realizadas (doubling search): 2917009\n  0.363662 seconds (247.15 k allocations: 11.062 MiB)\nTotal de comparaciones realizadas (doubling search): 8181939\n  1.246572 seconds (15.08 M allocations: 275.526 MiB)\nTotal de comparaciones realizadas (doubling search): 15754351\n  2.742887 seconds (27.03 M allocations: 457.676 MiB)\n\n\nDict{String, Dict} with 100 entries:\n  \"reunion\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"virtual\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"julio\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"votos\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"propuesta\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"nacional\"     =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"electoral\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"@m_ebrard\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"jovenes\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"_num\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 4212\", 4700=&gt;‚Ä¶\n  \"aqui\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"mayor\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"#envivo\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"üëâ\"           =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"mexico\"       =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"@epn\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"poder\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"pri\"          =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"encuentro\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"pena\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"gano\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"reune\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"plan\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"presidencial\" =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"resultados\"   =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  ‚ãÆ              =&gt; ‚ãÆ\n\n\nAqu√≠ podemos observar tiempos de ejecuci√≥n y n√∫mero de comparaciones similares a aquellos observados en b√∫squeda binaria lo cual es esperable ya que tiene un peor caso de $ O(n) $, sin embargo \\(B_1\\) ofrece la ventaja que mientras m√°s cercano est√© el valor buscado al inicio de la lista puede ser m√°s r√°pido que b√∫squeda binaria. Esto se aprecia claramente con las dos primeras listas de consultas, se ejecutan en menor tiempo y con menos n√∫mero de comparaciones que Busqueda binaria, esto es porque los valores son menores y est√°n m√°s cerca del inicio de la lista si es que existen."
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-no-acotada-b_2",
    "href": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-no-acotada-b_2",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "B√∫squeda no acotada \\(B_2\\)",
    "text": "B√∫squeda no acotada \\(B_2\\)\nSimilar a \\(B_1\\) pero en lugar de aumentar el rango de b√∫squeda en potencias de 2 (como en \\(B_1\\): \\(1, 2, 4, 8, 16, \\dots\\)),\n\\(B_2\\) podr√≠a usa potencias de potencias, como \\(2^{2^k}\\):\nEjemplo: \\(2, 4, 16, 256, 65536, \\dots\\)\nTiene complejidad de \\(O(\\log p)\\) donde \\(p\\) es la posici√≥n de inserci√≥n.\n\nusing JSON\n\nfunction busqueda_doblemente_doblada(arr, valor, contador)\n    n = length(arr)\n    \n    # Verificar el primer elemento\n    contador[] += 1\n    arr[1] == valor && return 1\n    \n    # Fase 1: B√∫squeda doblemente doblada \n    indice = 2\n    while indice &lt;= n\n        # Comparar el elemento actual\n        contador[] += 1\n        if arr[indice] == valor\n            return indice\n        elseif arr[indice] &gt; valor\n            break\n        end\n        \n        # Aumentamos el √≠ndice de manera m√°s agresiva \n        indice_previo = indice\n        indice *= indice\n        \n        # Verificar si nos pasamos del array\n        if indice &gt; n\n            # Retroceder y hacer b√∫squeda binaria entre indice_previo y n\n            indice = n\n            break\n        end\n    end\n    \n    # Ajustar los l√≠mites para la b√∫squeda binaria\n    bajo = max(indice √∑ 4, 1)  # Retrocedemos un paso\n    alto = min(indice, n)\n    \n    # Fase 2: B√∫squeda binaria precisa\n    while bajo &lt;= alto\n        medio = (bajo + alto) √∑ 2\n        contador[] += 1\n        \n        if arr[medio] == valor\n            return medio\n        elseif arr[medio] &lt; valor\n            bajo = medio + 1\n        else\n            alto = medio - 1\n        end\n    end\n    \n    return -1\nend\n\nfunction buscar_con_doblemente_doblada(datos_ordenados, elementos_a_buscar)\n    total_comparaciones = Ref(0)\n    resultados = Dict{String, Dict}()\n    \n    for (clave, arr) in datos_ordenados\n        resultados_clave = Dict{Any, Any}()\n        \n        for elemento in elementos_a_buscar\n            posicion = busqueda_doblemente_doblada(arr, elemento, total_comparaciones)\n            resultados_clave[elemento] = posicion != -1 ? \"Encontrado en posici√≥n $posicion\" : \"No encontrado\"\n        end\n        \n        resultados[clave] = resultados_clave\n    end\n    \n    return resultados, total_comparaciones[]\nend\n\nfunction procesar_archivo_y_buscar_dd(datos_ordenados, elementos_a_buscar)\n\n    resultados, total_comparaciones = buscar_con_doblemente_doblada(datos_ordenados, elementos_a_buscar)\n    \n    println(\"Total de comparaciones realizadas (doubling-doubling search): $total_comparaciones\")\n    return resultados\nend\n\nprocesar_archivo_y_buscar_dd (generic function with 1 method)\n\n\n\n@time begin \n    procesar_archivo_y_buscar_dd(lista,consultas1)\nend\n@time begin \n    procesar_archivo_y_buscar_dd(lista,consultas2)\nend\n@time begin \n    procesar_archivo_y_buscar_dd(lista,consultas3)\nend\n@time begin \n    procesar_archivo_y_buscar_dd(lista,consultas4)\nend\n\nTotal de comparaciones realizadas (doubling-doubling search): 3197982\n  0.417825 seconds (261.24 k allocations: 10.552 MiB, 24.58% compilation time)\nTotal de comparaciones realizadas (doubling-doubling search): 5158847\n  0.420363 seconds (183.97 k allocations: 8.652 MiB)\nTotal de comparaciones realizadas (doubling-doubling search): 10121250\n  3.014676 seconds (19.33 M allocations: 337.420 MiB, 67.26% gc time)\nTotal de comparaciones realizadas (doubling-doubling search): 13909594\n  1.143733 seconds (28.57 M allocations: 480.533 MiB)\n\n\nDict{String, Dict} with 100 entries:\n  \"reunion\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"virtual\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"julio\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"votos\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"propuesta\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"nacional\"     =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"electoral\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"@m_ebrard\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"jovenes\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"_num\"         =&gt; Dict{Any, Any}(31905=&gt;\"Encontrado en posici√≥n 4212\", 4700=&gt;‚Ä¶\n  \"aqui\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"mayor\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"#envivo\"      =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"üëâ\"           =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"mexico\"       =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"@epn\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"poder\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"pri\"          =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"encuentro\"    =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"pena\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"gano\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"reune\"        =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"plan\"         =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"presidencial\" =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  \"resultados\"   =&gt; Dict{Any, Any}(31905=&gt;\"No encontrado\", 4700=&gt;\"No encontrado‚Ä¶\n  ‚ãÆ              =&gt; ‚ãÆ\n\n\nComo podemos ver \\(B_2\\) no muestra diferencias significativas respecto a \\(B_1\\), en t√©rminos de tiempo de ejecuci√≥n se muestra similar y en n√∫mero de comparaciones tambi√©n est√° dentro del mismo orden de magnitud. Este algoritmo podr√≠a ser m√°s √∫ltil en busquedas dentro de listas de un tama√±o mucho mayor a las usadas en este experimento, ya que su fase de expansi√≥n crece de manera m√°s acelerada."
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-mediante-la-estructura-de-datos-skiplist",
    "href": "VillegasJoseAlbertoU4-T1.html#b√∫squeda-mediante-la-estructura-de-datos-skiplist",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "B√∫squeda mediante la estructura de datos SkipList",
    "text": "B√∫squeda mediante la estructura de datos SkipList\nPugh (1990) propuso como una alternativa simple y eficiente a estructuras de datos balanceadas como los √°rboles de b√∫squeda. Una SkipList es una lista enlazada jer√°rquica con m√∫ltiples niveles. Cada nivel es una sublista de los niveles inferiores, lo que permite realizar b√∫squedas en \\(O(logn)\\) en promedio.\nSe empieza en el nivel m√°s alto y se desciende progresivamente hasta encontrar el elemento deseado.Se asigna un nivel aleatorio al nuevo nodo y se insertan enlaces en los niveles correspondientes. Se eliminan los enlaces del nodo en cada nivel en el que aparece.\nDependen de la asignaci√≥n aleatoria de niveles a los nodos, lo que en promedio garantiza una estructura balanceada sin necesidad de reestructuraci√≥n expl√≠cita.\nAunque el peor caso es \\(O(n)\\), este es muy poco probable, y en la pr√°ctica, el tiempo esperado para b√∫squeda, inserci√≥n y eliminaci√≥n es \\(O(logn)\\). (Pugh, 1990)\n\n# Se cambia el tipo de datos en las listas del diccionario a enteros, para que el algortimo pueda funcionar correctamente\nfor clave in keys(lista)\n    lista[clave] = [Int(x) for x in lista[clave]]\nend\n\n\nusing Random\n\n# Estructura de nodo para la Skip List\nmutable struct SkipNode\n    value::Int\n    forward::Vector{Union{SkipNode, Nothing}}  # Array de punteros forward\nend\n\n# Estructura de la Skip List\nmutable struct SkipList\n    header::SkipNode\n    level::Int\n    max_level::Int\n    p::Float64  # Probabilidad para los niveles\nend\n\n# Funci√≥n para crear un nuevo nodo\nfunction create_node(value::Int, level::Int)\n    SkipNode(value, [nothing for _ in 1:level])\nend\n\n# Funci√≥n para inicializar una Skip List\nfunction create_skip_list(max_level::Int, p::Float64=0.5)\n    header = create_node(-1, max_level)  # Valor -1 como cabeza\n    SkipList(header, 1, max_level, p)\nend\n\n# Funci√≥n para determinar el nivel aleatorio de un nuevo nodo\nfunction random_level(skip_list::SkipList)\n    level = 1\n    while rand() &lt; skip_list.p && level &lt; skip_list.max_level\n        level += 1\n    end\n    return level\nend\n\n# Funci√≥n para insertar un valor en la Skip List\nfunction insert!(skip_list::SkipList, value::Int)\n    update = [nothing for _ in 1:skip_list.max_level]\n    current = skip_list.header\n    \n    # Buscar la posici√≥n de inserci√≥n\n    for i in skip_list.level:-1:1\n        while current.forward[i] !== nothing && current.forward[i].value &lt; value\n            current = current.forward[i]\n        end\n        update[i] = current\n    end\n    \n    current = current.forward[1]\n    \n    # Si el valor no existe, insertarlo\n    if current === nothing || current.value != value\n        new_level = random_level(skip_list)\n        \n        # Ajustar el nivel de la Skip List si es necesario\n        if new_level &gt; skip_list.level\n            for i in skip_list.level+1:new_level\n                update[i] = skip_list.header\n            end\n            skip_list.level = new_level\n        end\n        \n        # Crear el nuevo nodo\n        new_node = create_node(value, new_level)\n        \n        # Insertar el nodo\n        for i in 1:new_level\n            new_node.forward[i] = update[i].forward[i]\n            update[i].forward[i] = new_node\n        end\n    end\nend\n\n# Funci√≥n de b√∫squeda en la Skip List (con contador de comparaciones)\nfunction search(skip_list::SkipList, value::Int, counter::Ref{Int}=Ref(0))\n    current = skip_list.header\n    \n    # Buscar desde el nivel m√°s alto hacia abajo\n    for i in skip_list.level:-1:1\n        while current.forward[i] !== nothing\n            counter[] += 1  # Contar la comparaci√≥n\n            if current.forward[i].value == value\n                return true  # Valor encontrado\n            elseif current.forward[i].value &lt; value\n                current = current.forward[i]\n            else\n                break\n            end\n        end\n    end\n    \n    # Verificar en el nivel m√°s bajo\n    current = current.forward[1]\n    if current !== nothing && current.value == value\n        counter[] += 1\n        return true\n    end\n    \n    return false  # Valor no encontrado\nend\n\n# Funci√≥n para construir Skip List desde un array ordenado\nfunction build_skip_list(sorted_array::Vector{Int}, max_level::Int=16, p::Float64=0.5)\n    skip_list = create_skip_list(max_level, p)\n    for value in sorted_array\n        insert!(skip_list, value)\n    end\n    return skip_list\nend\n\n# Funci√≥n principal para buscar en m√∫ltiples listas\nfunction buscar_con_skip_lists(datos_ordenados, elementos_a_buscar)\n    total_comparaciones = Ref(0)\n    resultados = Dict{String, Dict}()\n    \n    for (clave, arr) in datos_ordenados\n        resultados_clave = Dict{Any, Any}()\n        \n        # Construir la Skip List para esta lista ordenada\n        skip_list = build_skip_list(arr)\n        \n        for elemento in elementos_a_buscar\n            counter = Ref(0)\n            encontrado = search(skip_list, elemento, counter)\n            total_comparaciones[] += counter[]\n            resultados_clave[elemento] = encontrado ? \"Encontrado\" : \"No encontrado\"\n        end\n        \n        resultados[clave] = resultados_clave\n    end\n    \n    return resultados, total_comparaciones[]\nend\n\n# Funci√≥n completa para procesar archivos\nfunction procesar_archivo_con_skip_lists(datos_ordenados, elementos_a_buscar)\n    #datos_ordenados = ordenar_json(p)\n    resultados, total_comparaciones = buscar_con_skip_lists(datos_ordenados, elementos_a_buscar)\n    \n    println(\"Total de comparaciones realizadas (Skip List): $total_comparaciones\")\n    return resultados\nend\n\nprocesar_archivo_con_skip_lists (generic function with 2 methods)\n\n\n\nprocesar_archivo_con_skip_lists(lista, consultas1)\n\nLoadError: cannot convert a value to nothing for assignment\ncannot convert a value to nothing for assignment\n\nStacktrace:\n  [1] error(s::String)\n    @ Base .\\error.jl:35\n  [2] nonnothingtype_checked(T::Type)\n    @ Base .\\some.jl:32\n  [3] convert(::Type{Nothing}, x::SkipNode)\n    @ Base .\\some.jl:37\n  [4] setindex!(A::Vector{Nothing}, x::SkipNode, i::Int64)\n    @ Base .\\array.jl:987\n  [5] insert!(skip_list::SkipList, value::Int64)\n    @ Main .\\In[19]:47\n  [6] build_skip_list\n    @ .\\In[19]:107 [inlined]\n  [7] build_skip_list\n    @ .\\In[19]:105 [inlined]\n  [8] buscar_con_skip_lists(datos_ordenados::Dict{String, Any}, elementos_a_buscar::Vector{Any})\n    @ Main .\\In[19]:121\n  [9] procesar_archivo_con_skip_lists(datos_ordenados::Dict{String, Any}, elementos_a_buscar::Vector{Any})\n    @ Main .\\In[19]:139\n [10] top-level scope\n    @ In[20]:1"
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#discusi√≥n-y-resultados",
    "href": "VillegasJoseAlbertoU4-T1.html#discusi√≥n-y-resultados",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "Discusi√≥n y resultados",
    "text": "Discusi√≥n y resultados\nA continuaci√≥n se muestran dos tablas en las que se resumen los resultados de los experimentos. Una de tiempos de ejecuci√≥n y la otra de N√∫mero de comparaciones.\n\nTabla. 1 Tiempo de ejecuci√≥n en segundos de cada lista de consultas con su respectivo orden de magnitud para cada algoritmo.\n\\[\\begin{array}{|l|c|c|c|c|}\n\\hline\n& \\textbf{B. binaria} & \\textbf{$B_0$} & \\textbf{$B_1$} & \\textbf{$B_2$} \\\\\n\\hline\nConsultas orden 10^0 & 0.857163 & 1.085884  & 0.480016 & 0.417825 \\\\\nConsultas orden 10^1 & 0.635125 & 0.574643  & 0.363662 & 0.420363 \\\\\nConsultas orden 10^2 & 1.125757 & 3.351496  & 1.246572 & 3.014676 \\\\\nConsultas orden 10^3 & 1.054306 & 45.471095  & 2.742887 & 1.143733 \\\\\n\\hline\n\\end{array}\\]\n\n\nTabla. 2 N√∫mero de comparaciones realizadas de cada lista de consultas con su respectivo orden de magnitud para cada algoritmo.\n\\[\\begin{array}{|l|c|c|c|c|}\n\\hline\n& \\textbf{B. binaria} & \\textbf{$B_0$} & \\textbf{$B_1$} & \\textbf{$B_2$} \\\\\n\\hline\n\\text{Consultas orden }10^0 & 9.66 \\times 10^6 & 1.28 \\times 10^6 & 1.23 \\times 10^6 & 3.20 \\times 10^6 \\\\\n\\text{Consultas orden }10^1 & 9.81 \\times 10^6 & 6.02 \\times 10^6 & 2.92 \\times 10^6 & 5.16 \\times 10^6 \\\\\n\\text{Consultas orden }10^2 & 1.00 \\times 10^7 & 7.67 \\times 10^7 & 8.18 \\times 10^6 & 1.01 \\times 10^7 \\\\\n\\text{Consultas orden }10^3 & 1.01 \\times 10^7 & 9.89 \\times 10^8 & 1.58 \\times 10^7 & 1.39 \\times 10^7 \\\\\n\\hline\n\\end{array}\\]\nLos resultados experimentales permiten observar diferencias fundamentales en el comportamiento de los algoritmos de b√∫squeda analizados:\n\n\n1. B√∫squeda Binaria\nComo era de esperarse por su complejidad te√≥rica \\(O(\\log n)\\), este algoritmo mantuvo tiempos de ejecuci√≥n y n√∫mero de comparaciones relativamente constantes, independientemente del orden de magnitud de los elementos en las listas de consulta (que variaban desde \\(10^0\\) hasta \\(10^3\\)). Sin embargo, se registr√≥ un incremento notable en el n√∫mero de asignaciones, lo cual puede atribuirse al manejo de n√∫meros m√°s grandes en las operaciones de comparaci√≥n.\n\n\n2. B√∫squeda no acotada Secuencial (\\(B_0\\))\nPara las consultas de menor orden presento rendimientos comparables al resto de los algoritmos, incluso mejores que en b√∫queda binaria, pero para las de mayor orden present√≥ un deterioro significativo en el rendimiento, con tiempos de ejecuci√≥n y comparaciones que aumentaron hasta un √≥rden de magnitud respecto a los otros algoritmos. Esto se explica por su naturaleza \\(O(n)\\) y porque, en muchos casos, el algoritmo oper√≥ en el peor escenario posible.\n\n\n3. B√∫squeda no acotada (\\(B_1\\))\nMostr√≥ un rendimiento comparable al de la b√∫squeda binaria (\\(O(\\log n)\\) en el peor caso), pero con una ventaja notable para valores cercanos al inicio de la lista. Esto fue particularmente evidente en las consultas con elementos de menor magnitud (\\(10^0\\) y \\(10^1\\)).\n\n\n4. B√∫squeda no acotada (\\(B_2\\))\nNo mostr√≥ diferencias significativas respecto a \\(B_1\\) en este experimento, manteni√©ndose en el mismo orden de magnitud tanto en tiempo como en comparaciones."
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#conclusi√≥n",
    "href": "VillegasJoseAlbertoU4-T1.html#conclusi√≥n",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "Conclusi√≥n",
    "text": "Conclusi√≥n\nDe lo anterior se puede concluir que probablemente b√∫squeda binaria sea la opci√≥n m√°s confiable para conjuntos ordenados de tama√±o arbitrario, sin embargo, \\(B_1\\) y \\(B_2\\) mostraron ser alternativas fiables en todos los casos y con potencial para ser usados en contextos espec√≠ficos, como tama√±os de listas muy grandes o busqueda de valores cercanos al inicio de la lista. Finalmente la busqueda secuencial si bien es el algoritmo m√°s simple, tambi√©n demostr√≥ ser el m√°s lento e ineficiente."
  },
  {
    "objectID": "VillegasJoseAlbertoU4-T1.html#bibliograf√≠a",
    "href": "VillegasJoseAlbertoU4-T1.html#bibliograf√≠a",
    "title": "4A. Reporte escrito. Experimentos y an√°lisis de algoritmos de b√∫squeda por comparaci√≥n.",
    "section": "Bibliograf√≠a",
    "text": "Bibliograf√≠a\nBaeza-Yates, R., & Salinger, A. (2010). Fast intersection algorithms for sorted sequences. In T. Elomaa, H. Mannila, & P. Orponen (Eds.), Algorithms and applications: Essays dedicated to Esko Ukkonen on the occasion of his 60th birthday (pp.¬†45‚Äì61). Springer. https://doi.org/10.1007/978-3-642-12476-1_3\nKnuth, D. E. (1998). The art of computer programming (2¬™ ed.). Addison Wesley Longman, Inc.\nPugh, W. (1990). Skip lists: A probabilistic alternative to balanced trees. Communications of the ACM, 33(6), 668-676. https://doi.org/10.1145/78973.78977"
  },
  {
    "objectID": "index.html#contenido",
    "href": "index.html#contenido",
    "title": "An√°lisis de Algoritmos 2025",
    "section": "",
    "text": "Unidad 1: Experimentos y an√°lisis\nUnidad 2: Estructuras de datos\nUnidad 3: Algoritmos de ordenamiento\nUnidad 4: Algoritmos de b√∫squeda\nUnidad 5: Intersecci√≥n de conjuntos"
  }
]